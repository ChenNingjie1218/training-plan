---
marp: true
theme: gaia
footer: '2023/6/16'
paginate: true
size: 16:9
math: katex
---

# using声明
`using namespace::name;`

# string
## 初始化string
```
string s1;
string s2(s1);
string s2 = s1;
string s3("value");
string s3 = "value";
string s(n,'c');//将s初始化为n个字符c组成的串
```

## string的操作
### getline函数
希望得到的字符串中保留输入时的空白符
```
getline(is,s);//从is中读一行赋给s，返回is
```
遇到换行符结束，换行符被读进来，但是**不存**过去。

### 读取string时
读取`string`对象时，会自动**忽略**开头的空白，从第一个真正的字符开始读起，直到遇到下一个空白:
*例如读取"      Hello World!   "，只会读到"Hello"*

### size_type类型
调用`size`函数返回的不是`int`也不是`unsigned`，而是`size_type`，是一个无符号整型数，要小心**不要跟带符号数混用**：
```
s.size() < n;//n如果是一个负数，则几乎肯定是true，n被转换成无符号值
```

### string相加
当把`string`对象和字符字面值及字符串字面值混在一条语句使用时，必须确保每个`+`的两侧的运算对象**至少有一个**是`string`

### 处理string对象中的字符
头文件cctype中有很多：
```
isalnum(c);//字母或数字
isalpha(c);//字母
iscntrl(c);//控制字符
isdigit(c);//数字
isgraph(c);//不是空格但可以打印
islower(c);//小写字母
isprint(c);//可打印字符，（空格或具有可视形式）
ispunct(c);//标点符号
isspace(c);//空白
isupper(c);//大写字母
isxdigit(c);//十六进制
tolower(c);//如果是大写字母，就输出小写字母，否则输出本身
toupper(c);//如果是小写字母，就输出大写字母，否则输出本身
```

## c标准库头文件
C标准库，用`cname`内容等价于`name.h`，表示这个**属于C语言标准库**的头文件，其中定义的名字从属于命名空间`std`

## 范围for
```
for(declaration:expression)//expression:序列对象 declaration:访问序列中元素的变量
    statement

例如:
for(auto c : str)
    cout << c << endl;
```
**范围for语句体内不应改变其所遍历序列的大小**
# vector
## 初始化
```
vector<T> v1
vector<T> v2(v1)
vector<T> v2 = v1
vector<T> v3(n, val)
vector<T> v4(n)
vector<T> v5{a,b,c...}
vector<T> v5 = {a,b,c...}
```

圆括号：构造
花括号：列表初始化。若无法执行列表初始化，编译器会尝试用默认值初始化。
### 直接初始化
1. 初始值已知且数量较少
2. 初始值是另一个vector对象的副本
3. 所有元素的初始值都一样

vector能高效增长，先定义一个空vector，然后再逐一添加更高效（除非元素都一样）。

## vector对象类型
**vector对象类型总是包含着元素的类型**
```
vector<int>::size_type  //正确
vector::size_type       //错误
```

## vector类型的比较
只有当元素的值可比较时，vector对象才能被比较

# 迭代器
养成使用迭代器和`!=`的习惯
## 尾后迭代器
`end`成员返回指向容器（或`string`对象）尾元素的下一位置。
*string对象不属于容器类型*

特殊的，如果容器为空，`begin`和`end`返回的都是尾后迭代器

## 获取
与指针不同，获取迭代器不是用取地址符
与指针相同，获取所指的元素是用解引用

## 类型
`iterator`和`const_iterator`
```
vector<int>::iterator it;
vector<int>::const_iterator it2
```
返回`const_iterator`用`cbegin`和`cend`

## 失效
但凡使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。会使迭代器失效

## 运算
### difference_type类型
迭代器比较时，必须合法且指向的是同一个容器的元素(或者尾元素的下一位置)
相减时，所得结果是两个迭代器的距离，类型为`difference_type`的带符号整型数

# 数组
定义数组时，必须指定数组的类型，不允许使用`auto`关键字由初始值的列表推断类型。数组的元素应为对象，因此不存在引用的数组。

不允许拷贝和赋值
## 字符数组特殊性
可以用字符串字面值初始化，注意结尾有个`\0`

## 复杂的数组声明
```
int (*Parray)[10] = &arr; //Parray指向一个含有10个整数的数组
int (&arrRef)[10] = arr;  //arrRef引用一个含有10个整数的数组
```
**由内向外阅读**

## 指针和数组
使用数组类型的对象其实是使用一个指向该数组首元素的**指针**
当使用数组作为一个auto变量的初始值时，推断得到的类型是**指针**而非数组
```
int ia[] = {0,1,2,3};
auto ia2(ia); //ia2是一个整型指针
```
当使用`decltype`关键字时上述转换不会发生
```
decltype(ia) ia3 = {0,1,2,3};
```
### 标准库函数`begin`和`end`
便于得到数组的尾后指针
定义在`iterator`头文件中

### `size_t`和`ptrdiff_t`
`size_t`是数组下标的类型，无符号类型
`ptrdiff_t`是指向同一数组的两个指针的差值类型，有符号类型
`cstddef`头文件中

允许给空指针加上或减去一个**值为0**的整型常量表达式
两个空指针也允许彼此相减，结果为0

内置的**下标运算符**可以处理负值：
```
int *p = a[2];
itn k = p[-2]; //a[0],这个p不是数组噢，不要以为里面类型是size_t了
```
### C风格字符串
C++程序中最好不好使用
```
//都不负责验证其字符串参数
strlen(p)
strcmp(p1, p2)
strcat(p1, p2)
strcpy(p1, p2)
```

`string`提供了一个专门返回C风格字符串的成员函数`c_str`

### 使用数组初始化`vector`对象
```
vector<int> ivec(begin(int_arr), end(int_arr));//只需要指明首元素地址和尾后地址就行了
```

### 使用范围for语句处理多维数组
```
//ia是一个二维数组
for (auto row : ia)
    for(auto col : row)//错误，row不是引用类型，编译器初始化row时会自动将这些数组形式的元素转换成指向该数组内首元素的指针
```
**使用范围`for`语句处理多维数组时，除了最内层的循环外，其他所有循环的控制变量都要是引用类型**

### 类型别名简化多维数组的指针
```
//将4个整数组成的数组命名为int_array
using int_array = int[4]
typedef int int_array[4]
```

## 缓冲区溢出
越界访问

