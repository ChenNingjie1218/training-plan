---
marp: true
theme: gaia
footer: ''
paginate: true
size: 16:9
math: katex
---

# 容器
一个容器就是一些特定类型对象的**集合**

## 顺序容器
提供了快速**顺序**访问元素的能力

- `vector`：变长数组
- `deque`：双端队列
- `list`：双向链表
- `forward_list`：单向链表，头插法
- `array`：固定大小的数组
- `string`：字符串

`string`和`vector`如果添加元素需要分配额外的存储空间，则每个元素都必须移动到新的存储空间中
`array`不支持**添加**和**删除**元素以及**改变容器大小**的操作
`forward_list`：没有`size`操作

**新标准库容器的性能几乎肯定与最精心优化过的同类数据结构一样好**，所以推荐使用标准库容器，通常使用`vector`是最好的选择

如果必须在**中间位置插入**元素，则考虑在输入阶段使用`list`，一旦输入完成，将其拷贝到`vector`中

---

## 迭代器

### 迭代器范围
用一对迭代器表示，为左闭合区间

### 反向迭代器
**反向遍历**容器的迭代器
带r的版本返回的迭代器

### 迭代器的使用
必须显示使用其类名：
```
list<string>::iterator iter;
```

### `begin`和`end`

- `cbegin`和`cend`
返回的是`const`成员

注意：
```
auto it = a.begin();//仅当a是const时，it是const_iteraotr
```
- `rbegin`和`rend`
反向迭代器


- `crbegin`和`crend`

---

## 容器定义和初始化
```
C c;//默认构造函数，默认初始化

//拷贝，c1和c2必须相同容器类型，相同元素类型，对于array，大小还要相同
C c1(c2);
C c1 = c2;

//列表初始化，元素类型必须与C的元素类型相容，对于array，数量必须小于等于，遗漏的元素进行值初始化
C c{a,b,c...};
C c = {a,b,c...};

C c(b,e)；//迭代器b和e范围中的元素的拷贝。(不包含e指向的元素)类型必须相容

C seq(n);//seq包含n个元素，这些元素进行值初始化，此构造函数是explicit的
C seq(n,t);//seq包含n个初始化值为t的元素
```

**相容：** 类型可以转换

---

如果元素类型**没有**默认构造函数，除了大小参数外，还**必须指定一个显式的元素初始值**。只有**顺序容器**的构造函数才接受大小参数，关联容器不支持。
```
//假定noDefault是一个没有默认构造函数的类型
vector<noDefault> v1(10,init); //正确，提供了一个元素初始化器
vector<noDefault> v2(10); //错误，没有提供
```

---

**标准库`array`的大小也是类型的一部分**:
```
array<int, 42>
array<int, 42>::size_type
```
- 一个默认构造的`array`是**非空**的，它包含了和大小一样多的元素。
- 如果元素类型是一个*类类型*，那么该类**必须有一个默认构造函数**，以便值初始化能够进行。
- `array`可以拷贝和对象赋值操作。(类型相同，即**元素类型和大小相同**)

---

## `assign`
**不适用于关联容器和`array`**
```
seq.assign(b,e);//seq中的元素替换为迭代器b和e范围内的元素。迭代器b和e不能指向seq中的元素
seq.aasign(il);//初始化列表il
seq.assign(n,t);//n个替换为t
```

## `swap`
- 除了`array`外，交换两个容器内容的操作保证会很快——**元素本身并未交换，`swap`只是交换了两个容器的内部数据结构**。

- 对一个`string`调用`swap`会导致迭代器、引用和指针失效。

- `swap`两个`array`会真正交换它们的元素
- 对于`array`，`swap`后，指针、引用和迭代器所绑定的元素不变，但是**元素值变**了。

*推荐使用非成员版本的`swap`*

## 向顺序容器添加元素
```
这些操作会改变容器的大小，array不支持这些操作
forward_list有自己专有版本的insert和emplace
forward_list不支持push_back和emplace_back
vector和string不支持push_front和emplace_front

c.push_back(t);
c.emplace_back(args);

c.push_front(t);
c.emplace_front(args);

//在迭代器p前创建一个值为t或由args创建的元素，返回新元素迭代器。
c.insert(p,t);
c.emplace(p,args);

//返回指向新添加的第一个元素的迭代器
c.insert(p,n,t);
c.insert(p,b,e);
c.insert(p,il);
```
- 用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个**拷贝**，而不是对象本身。
- 传递给`insert`的一对迭代器，不能指向添加元素的目标容器。
- `emplace`是将参数传递给元素类型的构造函数，必须匹配。

## 访问元素
如果容器中没有元素，访问操作的结果是**未定义**的。
```
at和下标操作只适用于string、vector、deque、array
back不适用于forward_list

//返回的都是引用
c.back();
c.front();
c[n];
c.at(n);//at要检查是否越界，越界抛出out_of_range异常
```

## 删除元素
```
这些操作会改变容器的大小，不适用于array
forward_list有特殊版本的erase
forward_list不支持pop_back
vector和string不支持pop_front

//若c为空，则函数行为未定义。
//函数返回空。如果需要其值，弹出之前就要保存。
c.pop_back();
c.pop_front();

c.erase(p);//返回指向被删元素之后的迭代器
c.erase(b,e);
c.clear()
```
**删除元素之前，必须确保它们是存在的！！！**

### 特殊的`forward_list`操作
```

lst.before_begin()//首前迭代器，不能解引用
lst.cbefore_begin()

//迭代器p之后，p若为尾后迭代器，则行为未定义
lst.insert_after(p,t)
lst.insert_after(p,n,t)
lst.insert_after(p,b,e)//b，e不能指向lst内
lst.insert_after(p,il)
emplace_after(p,args)
lst.erase_after(p)
lst.erase_after(b,e)
```

## 改变容器大小
```
resize不适用于array
c.resize(n)
c.resize(n,t)
```
如果容器保存的是**类类型**，`resize`添加新元素，**必须提供默认构造函数**

---

## 容器操作可能使迭代器失效
添加或删除元素后，迭代器可能失效。注意循环中用`end`，不要一开始存下来用，每次使用时再使用`end`。

## 管理容量的成员函数
```
shrink_to_fit只适用于vector、string和deque
capacity和reserve只适用于vector和string

c.shrink_to_fit()//将capacity减少为与size相同大小
c.capacity()//不重新分配内存空间的话，c可以保存多少元素
c.reserve(n)//分配至少能容纳n个元素的内存空间
```
调用`shrink_to_fit`并不保证一定退回内存空间

## 额外的string操作
```
string s(cp,n)//cp指向数组的前n个
string s(s2,pos2)//string s2 从下标pos2开始
string s(s2,pos2,len2)//string s2从下标pos2开始，不管len2是多少，至多s2.size()-pos2个字符

//当从const char*创建string时，指针指向的数组必须以空字符结尾，如果传递了计数值，就不必了。
char noNull[] = {'H', 'i'};
string s(noNull);//未定义：noNull不是以空字符结束

s.substr(pos, n)//n默认值为s.size()-pos
```

### `append`
在`string`末尾进行插入的一种简写：
```
string s("C++ Primer"), s2 = s;

s.insert(s.size(), " 4th Ed.");
//等价于
s.append(" 4th Ed.");
```

### `replace`
调用`erase`和`insert`的一种简写：
```
s.replace(range, args);//range是一个下标和一个长度，或者一对指向s的迭代器

s.erase(11, 3);
s.insert(11, "5th");

//等价于
s.replace(11, 3, "5th");
```

### `string`搜索操作
```
搜索操作返回指定字符出现的下标，如果未找到则返回string::npos

s.find(args)//查找s中args第一次出现的位置
s.rfind(args)//查找s中args最后一次出现的位置
s.find_first_of(args)//args中任何一个字符第一次出现的位置
s.find_last_of(args)
s.find_first_not_of(args)//第一个不在args中的字符
s.find_last_not_of(args)

args必须是以下形式之一
//pos默认为0，指针cp指向的以空字符结尾的C风格字符串
c，pos
s2，pos
cp，pos

cp，pos，n
```

### `compare`函数
```
s2
pos1,n1,s2
pos1,n1,s2,pos2,n2
cp
pos1,n1,cp
pos1,n1,cp,n2
```

### 数值转换
- `string`参数中第一个非空白符必须是符号(+-)或数字。
- 可以以`0x`或`0X`开头表示十六进制。
- 可以以小数点`.`开头,并可以包含`e`和`E`来表示指数部分
- 根据基数不同，可以包含字母字符
```
to_string(val)

//b表示基数，默认为10。p是size_t指针，用来保存s中第一个非数值字符的下标，默认为0。
stoi(s,p,b)
stol(s,p,b)
stoul(s,p,b)
stoll(s,p,b)
stoull(s,p,b)

stof(s,p)
stod(s,p)
stold(s,p)
```

## 容器适配器
`stack`、`queue`和`priority_queue`
一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。

- `stack`和`queue`是基于`deque`实现的
- `priority_queue`是基于`vector`实现的

可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型
```
stack<string, vector<string>> str_stk;
```

**适配器不能构造在`array`之上**：无添加和删除元素的能力
**也不能构造在`forward_list`之上**：不支持访问尾元素

```
栈
s.pop()
s.push(item)
s.emplace(args)
s.top()

队列
q.pop()
q.front()
q.back()//只适用于queue
q.top()
q.push(item)
q.emplace(args)
```

