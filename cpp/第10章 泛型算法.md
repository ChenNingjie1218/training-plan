---
marp: true
theme: gaia
footer: ''
paginate: true
size: 16:9
math: katex
---

头文件`algorithm`或`numeric`中

**算法永远不会执行容器操作**

## 只读算法
- `find`
```
auto result = find(vec.cbegin(), vec.cend(), val);
```
`find`返回第二个参数来表示搜索失败


- `accumulate`
```
int sum = accumulate(vec.cbegin(), vec.cend(), 0);

//错误：const char*上没有定义+运算符
string sum = accumulate(v.cbegin(), v.cend(), "");
```
`accumulate`的第三个参数的类型决定了函数中**使用哪个加法运算符**以及**返回值的类型**。

- `count`
```
int num = count(vec.cbegin(), vec.cend(), val);
```
`count`返回给定值在序列中出现的次数

## 

**对于只读算法，最好使用`cbegin`和`cend`**，如果计划利用返回的迭代器改变元素值，就需要使用`begin`和`end`

- `equal`
```
equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());
```
对于只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长

## 写容器算法
一些算法会自己向输入范围写入元素。这些算法本质上并不危险，它们最多写入与给定序列一样多的元素。

- `fill`
```
fill(vec.begin(), vec.end(), 0);
```

- `fill_n`
```
fill_n(vec.begin(), n, val);

//切勿在一个空容器上调用fill_n
vector<int> vec; //空向量
fill_n(vec.begin(), 10, 0);//此行为是未定义的
```
**向目的位置迭代器写入数据的算法，假定目的位置足够大，能容纳要写入的元素。**

### 插入迭代器
向容器中添加元素的迭代器
- `back_inserter`
头文件`iterator`中的一个函数
接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。
```
auto it = back_inserter(vec);
*it = 42;//将42插入进去了

fill_n(back_inserter(vec), 10, 0);
//传递一个插入迭代器，每次赋值都会在vec上调用push_back
```

- `front_inserter`
用的`push_front`。

- `inserter`
接受第二个参数，元素被插入到给定迭代器所表示的元素**之前**。
```
it = c.insert(it, val); //it指向新加入的元素
```

### 拷贝算法
- `copy`
```
//ret指向拷贝到a2的尾元素之后的位置
auto ret = copy(begin(a1), end(a1), a2);
//传递给copy的目的序列至少要包含与输入序列一样多的元素
```
- `replace`
```
//后两个一个是要搜索的值，一个是新值
replace(ilst.begin(), ilst.end(), 0, 42)
```
- `replace_copy`
希望保持原序列不变。
```
//接受额外第三个迭代器参数，指出调整后序列的保存位置
replace_copy(ilst.cbegin(), ilst.cend(), back_inserter(ivec), 0, 42);
```

## 重排元素算法
- `unique`
**覆盖**相邻的重复元素，使不重复元素出现在序列开始部分。
```
//返回指向不重复区域之后一个位置的迭代器。
auto end_unique = unique(words.begin(), words.end());
```

### 谓词
一个可调用表达式。
- 一元谓词
- 二元谓词

接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须要能**转换**为谓词的参数类型。

### 排序算法
- sort
- stable_sort
稳定排序算法，保持相等元素的原有顺序。
```
sort(words.begin(), words.end(), isShoerter);
stable_sort(words.begin(), words.end(), isShoerter);
```

### `lambda`表达式
希望进行的操作需要更多参数，超出了算法对谓词的限制。
- `find_if`
查找第一个具有特定大小的元素，与`find`不同的是，它的第三个参数是一个**谓词**。它返回第一个使谓词返回非0值的元素，如果不存在这样的元素，则返回尾迭代器。

- 可调用对象：可以使用调用运算符的对象或表达式。
    1. 函数
    2. 函数指针
    3. 重载了函数调用符的类
    4. `lambda`表达式

*可以将其理解为一个未命名的内联函数。与函数类似，具有返回类型，参数列表，函数体；与函数不同，`lambda`可能定义在函数内部。*
```
[capture list](parameter list) -> return type {function body}
```
- `capture list`:捕获列表
**捕获列表只用于局部非`static`变量，`lambda`可以直接使用局部`static`变量和在它所在函数之外声明的名字。**
- 与普通函数不同，`lambda`必须使用**尾置返回**来指定返回类型

- 可以忽略参数列表和返回类型，但**必须永远包含捕获列表和函数体**
```
auto f = [] {return 42;};
```
- **如果`lambda`的函数体包含任何单一`return`语句之外的内容，且未指定返回类型，则返回`void`**
- 与普通函数不同，`lambda`不能有默认参数

### `for_each`算法
```
for_each(words.begin(), words.end(),
        [] (const string &s){cout << s << " ";});
```

### `lambda`捕获和返回
当定义一个`lambda`时，编译器生成一个与`lambda`对应的新的（未命名的）类类型。

- 值捕获
被捕获的变量的值是在`lambda`**创建**时**拷贝**的，而不是调用时拷贝

- 引用捕获
如果采用引用方式捕获一个变量，就必须确保被引用的对象在`lambda`**执行的时候是存在的**。
**引用捕获有时是必要的**：例如对于不能拷贝的对象

*尽量减少捕获的数据量，避免捕获指针或引用*

- 隐式捕获
`&`告诉编译器采用捕获引用方式，`=`则表示采用值捕获方式
```
[=](const string &s){return s.size() >= sz;};
```
混合使用隐式捕获和显式捕获：
```
[&, c](const string &s){os << s << c;};
```
捕获列表中**第一个元素**必须是一个`&`或`=`
显式捕获的变量**必须**使用与隐式捕获**不同**的方式。

#### 可变`lambda`
默认情况下，对于一个值被拷贝的变量，`lambda`不会改变其值。如果希望改变一个被捕获的变量的值，就必须在参数列表首加上关键字`mutable`
```
[v1] () mutable{return ++v1;};
```

#### 指定`lambda`返回类型
- `transform`
第三个迭代器表示目的位置，对输入序列中的每个元素调用可调用对象，并将结果写到目的位置。
```
//只有单一return，可以被推断为int
transform(vi.begin(), vi.end(), vi.begin(),
            [](int i ) {return i < 0 ? -i : i;});

//错误：编译器推断返回类型为void
transform(vi.begin(), vi.end(), vi.begin(),
            [](int i ) {if(i < 0) return -i; else return i;});

//必须使用尾置返回类型
transform(vi.begin(), vi.end(), vi.begin(),
            [](int i ) -> int
            {if(i < 0) return -i; else return i;});
```

### 参数绑定
- `bind`
头文件`functional`中
接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。
```
auto newCallable = bind(callable, arg_list);
//当我们调用newCallable的时候，会调用callable，并传递给它arg_list中的参数
```

- 占位符`_n`
```
auto check6 = bind(check_size, _1, 6);
//分析：
//只有一个占位符，check6只接受单一参数，它会把这个参数传递给check_size
```

名字`_n`都在命名空间`placeholders`中，而这个命名空间本身在`std`中。
```
using namespace std::placeholders
```
该命名空间也在头文件`functional`中

```
auto g = bind(f, a, b, _2, c, _1);
//分析：
//新调用对象g，有两个参数，第一个参数作为f的第五个参数，第二个参数作为f的第三个参数，f的其他参数分别为a，b，c
```
可以用`bind`**重排参数顺序**

- 绑定引用参数
默认情况下，`bind`的那些不是占位符的参数被拷贝到`bind`返回的可调用对象中。如果这些对象不能被拷贝，则需要使用`ref`函数
```
for_each(words.begin(), words.end(),
        bind(print, ref(os), _1, ' '));
```
- `ref`
返回一个对象，包含给定的引用，此对象是可以拷贝的。
定义在头文件`functional`中

- `cref`
生成一个保存`const`引用的类

## 流迭代器
- `istream_iterator`
必须指定迭代器将要读写的对象类型，该类型必须定义了输入运算符
```
istream_iterator<int> int_it(cin);//从cin读取int
istream_iterator<int> int_eof;//默认初始化迭代器，当做尾后迭代器
```
**允许懒惰求值**：将`istream_iterator`绑定到一个流时，标准库并**不保证迭代器立即从流读取数据**，只保证在**第一次解引用之前**，从流中读取数据的操作已经完成了。
```
//后置递增运算读取流，返回迭代器的旧值
//解引用迭代器，获得从流读取的前一个值
*in_iter++;
```
- `ostream_iterator`
可以提供(可选)第二个参数，必须是一个C风格字符串。
必须将`ostream_iterator`绑定到一个指定的流，不允许空的或表示尾后位置的`ostream_iterator`
```
ostream_iterator<int> out_iter(cout, " ");
for(auto e : vec)
    *out_iter++ = e;//赋值语句实际上将元素写到out_iter所指流中

//可以通过调用copy来打印vec中的元素，这样更简单：
copy(vec.begin(), vec.end(), out_iter);
```

## 反向迭代器
从尾元素向首元素反向移动的迭代器
除了`forward_list`之外，其他容器都支持。
- `rbegin`
- `rend`
- `crbegin`
- `crend`

*可以通过向`sort`传递反向迭代器来将`vector`整理为递减序*
- `base`
将反向迭代器转换为普通迭代器。
```
//rcomma为首前迭代器
cout << string(rcomma.base(), line.cend()) << endl;
```
**返回的迭代器与原迭代器指向的并不是相同元素！！！**

## 算法命名规范
- 使用重载形式传递一个谓词
接受谓词参数来代替`<`或`==`运算符的算法，不接受额外参数的算法，通常都是重载函数。
```
unique(beg, end);
unique(beg, end, comp);
```

- _if版本的算法
接受一个元素值的算法通常有另一个不同名的版本，该版本接受一个谓词
```
find(beg, end, val);
find_if(beg, end, pred); //查找第一个令pred为真的元素
```

- 拷贝版本_copy
写到额外目的空间的算法都在名字后面加一个`_copy`
```
reverse(beg, end);
reverse_copy(beg, end, dest);
```

- 同时提供_copy和_if
```
//将偶数元素从v1拷贝到v2;v1不变！
remove_copy_if(v1.begin(), vq.end(), back_inserter(v2),
                [](int i){return i%2;});
```
## 特定容器算法
对于交换元素，链表版本的算法的性能比对应的通用版本好得多。因为只改变链接。

*对于`list`和`forward_list`，应该优先使用成员函数版本的算法*

```
都返回void

//lst和lst2都必须有序，元素将从list2中删除。
lst.merge(lst2) // <
lst.merge(lst,comp) // comp

lst.remove(val) // ==
lst.remove_if(pred) // 一元谓词为真

lst.reverse() //反转

lst.sort() // <
lst.sort(comp) // comp

lst.unique() // ==
lst.unique(pred) // 二元谓词为真
```

- `splice`
链表数据结构特有的
```
lst.splice(args)或lst.splice_after(args)

//p是指向lst中元素的迭代器或首前迭代器。
//将lst2所有元素移动到p之前的位置，或首前之后的位置。元素从lst2中删除。
//类型必须相同，且不能是同一个链表。
(p, lst2)

//lst2可以是同一个链表
(p, lst2, p2)
//p不能是b，e范围内的
(p, lst2, b, e)
```

**链表特有版本会改变底层的容器**