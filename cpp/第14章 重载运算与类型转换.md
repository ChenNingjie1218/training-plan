---
marp: true
theme: gaia
footer: ''
paginate: true
size: 16:9
math: katex
---

# 重载运算符
- 参数数量跟运算对象数量一样多
- 除了调用运算符外，不能含有默认参数
- 是类的成员或者含有类类型参数

## 直接调用重载运算符
```
data1 + data2;
//等价于
operator+(data1, data2);
```

## 不能被重载的运算符
- 无法保留求值顺序、短路求值属性
- 对于类类型有内置含义

通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符

## 选择作为成员还是非成员
- 赋值(`=`)、下标(`[]`)、调用(`()`)和成员访问箭头(`->`)运算符**必须是成员**
- 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用，通常应该是成员
- 具有**对称性**的运算符。例如算术、相等性、关系和位置运算符，通常应该是**非成员函数**。

如果定义成成员函数，它的**左侧**运算对象必须是运算符所属类的一个对象。
```
string u = "hi" + s;//如果+是string的成员，则产生错误，相当于在调用“hi”.operate+(s)
```

## 重载输出运算符
尽量减少格式化操作(换行符等)

**输入输出运算符必须是非成员函数**

IO运算符通常需要读写类的非公有数据成员，所以一般被声明为友元。

## 重载输入运算符
第二个参数必须是个**非常量**(要读入)
输入运算符必须处理**输入失败**的情况，而输出运算符不需要。

## 重载相等运算符
如果定义了相等，也应该定义`operator!=`

## 重载递增和递减运算符
```
StrBlobPtr& operator++(); //前置运算符
StrBlobPtr& operator++(int);//后置运算符

//前置版本
StrBlobPtr& StrBlobPtr::operator++(){
    //如果curr已经指向了容器的尾后位置，则无法递增它
    check(curr, "increment past end of StrBlobPtr");
    ++curr;
    return *this;
}

//后置版本
StrBlobPtr& StrBlobPtr::operator++(int){
    //无须检查
    StrBlobPtr ret = *this;//记录当前值
    ++*this;
    return ret;
}

p.operator++(0);//显式调用后置版本
p.operator++();//显式调用前置版本
```

## 重载函数调用运算符
同时能存储状态，更加灵活

定义了调用运算符的类称为**函数对象**

### `lambda`是函数对象
编译器将`lambda`表达式翻译成一个未命名类的未命名对象。

默认情况下`lambda`不能改变它捕获的变量，因此由`lambda`产生的类当中的函数调用运算符是一个`const`成员函数。
```
[sz](const string &a){
    return a.size() >= sz;
}

//产生的类：
class SizeComp{
    SizeComp(size_t n):sz(n){}
    bool operator()(const string &s) const{
        return s.size() >= sz;
    }
private:
    size_t sz;
}
```

## 标准库函数对象
头文件`functional`
```
//算术
plus<Type>
mins<Type>
multiplies<Type>
divides<Type>
modulus<Type>
negate<Type>

//关系
equal_to<Type>
not_equal_to<Type>
greater<Type>
greater_equal<Type>
less<Type>
less_equal<Type>

//逻辑
logical_and<Type>
logical_or<Type>
logical_not<Type>
```

对于指针同样适用！关联容器使用`less<key_type>`对元素排序，所以定义一个**指针**的`set`或在`map`中使用**指针作为关键字**无须直接声明`less`

## 可调用对象与`function`
可调用对象
- 函数
- 函数指针
- `lambda`表达式
- `bind`创建的对象
- 重载了函数调用运算符的类

不同类型的可调用对象可能共享一种调用形式

一个调用形式对应一个函数类型
```
int(int, int)//一个函数类型，接受两个int，返回一个int
```


### 标准库`function`类型
头文件`functional`中
相当于将调用形式相同的定义为一个新的类型
```
function<T> f; //f是一个用来存储可调用对象的空function，这些可调用对象的调用形式应该与函数类型T相同(即T是retType(args))
function<T> f(nullptr); //显式地构造一个空function
function<T> f(obj); //在f中存储可调用对象obj的副本
f //将f作为条件：含有可调用对象时为真
f(args) //调用f中的对象，参数是args

//定义为function<T>的成员的类型
result_type
argument_type
first_argument_type
second_argument_type
```
**不能直接将重载函数的名字存入`function`类型的对象中**，可存储函数**指针**以避免**二义性**

## 类型转换运算符
```
operator type() const;
```
**一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是`const`**

类型转换运算符是**隐式执行**的，无法传递实参，即不能使用任何形参。

尽管不负责指定返回类型，但实际上每个类型转换函数都会返回一个对应类型的值。

### 显式的类型转换运算符
```
explicit operator int() const{return val;}

si + 3;//错误
static_cast<int>(si) + 3;//正确：显式地请求类型转换
```
如果表达式被用作条件，则编译器会将显式的类型转换自动应用于它

**不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换**，防止产生二义性