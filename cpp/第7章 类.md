---
marp: true
theme: gaia
footer: '2023/6/16'
paginate: true
size: 16:9
math: katex
---

# 构造函数
构造函数用来初始化类对象的数据成员。当类的对象被创建时，就会执行构造函数

构造函数没有返回类型。

构造函数可以重载。

如果类没有任何构造函数则编译器自己会创建默认构造函数（适用范围很小，尽量不要如此）

在实际中，如果定义了其他构造函数，最好也提供一个默认构造函数。

# class和strutc
class 和 struct 的唯一一点区别就是默认访问权限不同。
当希望类的所有成员是 public 时，用struct

# 友元
友元声明只能出现在类的内部，但是具体位置不限，不是类的成员，不受public、private 限制。

最好在类的开始或结束位置集中声明友元。

# 内联成员函数
1. 在类内定义函数，为隐式内联。
2. 在类内用关键字 inline 显式声明成员函数。
3. 在类外用关键字 inline 定义成员函数。
4. 同时在类内类外用 inline 修饰

inline 成员函数应该与类定义在同一个头文件中

# 返回*this的成员函数
this 指针指向类本身，即 this 是类的地址，*this 就是类本身。

可以定义返回类型为类对象的引用的函数。如果定义的返回类型不是引用，返回的就是*this 的副本了。

const 函数如果以引用的形式返回 this，返回类型就是一个常量引用。

# 委托构造函数
委托构造函数通过其他构造函数来执行自己的初始化过程。
```
class Student{
public:
    Student(string nameIn,int ageIn):name(nameIn),age(ageIn){}
    Student():Student(" ",18){} //这就是委托构造函数
    Student(string s):Student(s,18){} //这也是委托构造函数
}
```

# explicit
抑制构造函数定义的隐式转换

关键字 explicit 只对一个实参的构造函数有效。因为需要多个实参的构造函数本来就不执行隐式转换。

explicit 只在类内声明构造函数时使用，在类外定义时不加。类似 static 成员函数

```
class Sales_data {
public:    
    explicit Sales_data(const string& s) : bookNo(s) { } //不能再执行从 string 到 Sales_data 的隐式转换。
private    
    string bookNo;   
}
iter.combine(null_book);   //错误，不能执行从 string 到 Sales_data 的隐式初始化
```

## explicit 构造函数只能用于直接初始化
explicit 构造函数只能用于直接初始化，不能用于使用 "=" 的拷贝初始化。理解：因为 “=” 实际上是采用了拷贝赋值运算符，在传参时会进行隐式转换。

不加 explicit 的转换构造函数，可以在赋值、传参、从函数返回等场合执行隐式转换，加了 explicit 后，就不能隐式转换了，也就是加了 explicit 的转换构造函数的意义就只是定义了一个新的构造函数，不具有提供隐式转换机制的额外功能了。

```
Sales_data item1(null_book);  //正确
Sales_data item2 = null_book; //错误
```

# constexpr 构造函数
类的构造函数不能是 const 的，但字面值常量类的构造函数可以是 constexpr 函数。

constexpr 构造函数可以声明成 =default 或 =delete。

constexpr 构造函数的函数体应该是空的（原因：constexpr 函数的函数体只能包含一条返回语句，而构造函数不能包含返回语句）

constexpr 构造函数必须初始化所有数据成员。初始值必须是常量表达式或使用其自己的 constexpr 构造函数。

使用前置关键字 constexpr 来声明 constexpr 构造函数

```
class Debug{
public:
    constexpr Debug(bool b=true):a(b){};
private:
    bool a;
};//定义一个类记得加分号
constexpr Debug prod(false);//定义一个 Debug 类型的对象。实参应为常量表达式。
```

# 类的静态成员
类的静态成员与类本身直接关联，而不是与类的对象保持关联。

静态成员可以是 public 或 private 的。
静态成员不与任何对象绑定在一起。

静态数据成员可以是常量、引用、指针、类等。

静态成员函数不包含 this 指针，不能声明为 const 的，不能在 static 函数体内使用 this 指针。

## 定义静态成员
可以在类内或类外定义静态成员。当在类外定义时，不能重复 static 关键字，static 只出现在类内的声明中。

只有 constexpr 类型的静态数据成员可以在类内初始化，但是也需要在类外定义。

其他的静态数据成员都在类内声明，类外定义并初始化。

## 静态成员可以用的特殊场景
静态数据成员可以是不完全类型，比如静态数据成员的类型可以是它所属的类类型本身。

静态成员可以作为默认实参。