---
marp: true
theme: gaia
footer: ''
paginate: true
size: 16:9
math: katex
---
# 类的基本思想
数据抽象和封装
## 数据抽象
依赖于接口和实现分离的编程技术

定义在类内部的函数是隐式的`incline`函数

## this
成员函数通过名为`this`的额外的隐式参数来访问调用它的那个对象。用该对象的地址初始化`this`

**任何自定义名为“this”的参数或变量的行为都是非法的**

`this`是一个**常量指针**，不允许改变`this`中保存的地址

## const成员函数
`const`的作用是修改隐式`this`指针的类型。默认情况`this`都是指向类类型**非常量**版本，意味着**不能把`this`绑定到一个常量对象上**，同样使得我们**不能在常量对象上调用成员函数**。

C++允许把`const`关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的`const`表示`this`是一个**指向常量**的指针。

# 构造函数
构造函数用来初始化类对象的数据成员。当类的对象被创建时，就会执行构造函数

构造函数**没有返回类型**。

构造函数不能被声明成`const`的，因为初始化时**还没获得“常量”属性**。

构造函数**可以重载**。

如果类没有任何构造函数则编译器自己会创建默认构造函数（适用范围很小，尽量不要如此）
在实际中，如果定义了其他构造函数，**最好也提供一个默认构造函数**。

## 构造函数初始值列表
为新创建的对象的一个或几个数据成员赋初值。
```
Sales_data(cosnt std::string &s, unsigned n, double p):
            bookNo(s), units_sold(n), revenue(p*n) {}
```

如果编译器不支持类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员
# 拷贝、赋值和析构
拷贝：初始化、以值的方式传递或返回一个对象
赋值：`=`
析构：执行销毁操作

如果没有主动定义这些操作，编译器能替我们合成，但某些类合成的版本无法正常工作，*特别是类需要**分配类对象之外的资源**时*。如果类包含`vector`或`string`成员，则合成版本能够正常工作。

# `class`和`struct`
`class`和`struct`的唯一区别就是**默认访问权限不同**。
当希望类的**所有成员**是`public`时，用`struct`

# 友元
允许其他类或函数访问类的非公有成员。加上一句以`friend`关键字开头的函数声明即可。

友元声明只能出现在类的内部，但是具体位置不限，不是类的成员，不受`public`、`private`限制。

友元声明**仅仅指定了访问的权限**，而非一个真正意义上的函数声明。如果希望类的用户能够调用某个友元函数，**必须在友元声明之外再专门对函数进行一次声明**。最好在类的开始或结束位置集中声明友元。

## 类之间的友元关系
类可以把其他类、其他类的成员函数定义成友元。以便其访问自己包括非公有成员的所有成员。

以其他类的成员函数作为友元，注意**仔细组织程序的结构**以满足声明和定义的彼此依赖关系。对于一组重载的成员函数作为友元，每个都需要声明友元。

友元关系**不存在传递性**。

类和非成员函数的声明**不是必须**在它们的友元声明之前。友元声明的作用是**影响访问权限**，它本身**并非普通意义上的声明**。


# 内联成员函数
1. 在类内定义函数，为隐式内联。
2. 在类内用关键字`inline`显式声明成员函数。
3. 在类外用关键字`inline`定义成员函数。
4. 同时在类内类外用`inline`修饰

最好只在类外定义的地方说明`incline`

`inline`成员函数应该与类定义在同一个头文件中

# 可变数据成员
加上`mutable`关键字。`const`成员函数也可以改变它的值。

# 返回*this的成员函数
`this`指针指向类本身，即`this`是类的地址，`*this`是类本身。

可以定义返回类型为类对象的引用的函数。如果定义的返回类型不是引用，返回的就是`*this`的**副本**了。

`const`函数如果以引用的形式返回`this`，返回类型就是一个**常量引用**。

# 类的声明
前向声明：引入类名字，指明是类类型。

不完全类型：声明之后，定义之前。可以定义指向这种类型的**指针或引用**，也可以声明（**但是不能定义**）以这种类型作为**参数**或者**返回类型**的函数。

一个类的**成员类型不能是它自己**（类全部完成后才算被定义）。类**允许包含指向自身类型的引用或指针**。（名字出现就被认为是声明过了）

# 类的作用域
在类的外部，成员名字被**隐藏**。

一旦遇到类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体。但是**返回类型必须指明它是哪个类的成员**。
```
Window mgr::ScreenIndex
Window mgr::addScreen(const Screen &s){
    ...
}
```

编译器处理完类中的全部声明后才会处理成员函数的定义。

如果类成员使用了外层作用域中的某个名字，该名字**代表一种类型**，则类**不能**在之后重新定义该名字。类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。

**不要把成员名字作为参数或其他局部变量使用**。即不应该隐藏同名的成员。如果隐藏了，可以通过加上类的名字或显式地使用`this`指针来强制访问成员。

# 必不可少的构造函数初始值
`const`、引用，或者属于某种未提供默认构造函数的类类型，我们**必须通过构造函数初始值列表**为这些成员提供初始值。（即不能用先初始化后赋值的形式）

## 成员初始化顺序
类成员的初始化顺序与它们在类**定义中的顺序一致**。**最好令构造函数初始值顺序与成员声明的顺序保持一致，尽可能避免用某些成员初始化其他成员**。

# 委托构造函数
委托构造函数通过其他构造函数来执行自己的初始化过程。
```
class Student{
public:
    Student(string nameIn,int ageIn):name(nameIn),age(ageIn){}
    Student():Student(" ",18){} //这就是委托构造函数，委托给俩参数的构造函数
    Student(string s):Student(s,18){} //这也是委托构造函数
}
```

# 使用默认构造函数
```
Sales_data obj();//错误，声明了一个不接受任何参数的函数并且其返回值是Sales_data类型的对象

Sales_data obj; //正确，使用默认构造函数进行初始化的对象。
```

# 隐式的类类型转换
能通过一个实参调用的构造函数定义了一条从*构造函数的参数类型*向*类类型*隐式转换的原则
```
string null_book = "9-999-99999-9";
item.combine(null_book);//编译器用给定的string自动创建了一个Sales_data对象，然后传递给combine
```
**只允许一步类类型转换**
```
item.combine("9-999-99999-9");//错误，编译器只会自动执行一步类型转换

//解决办法：显式地把字符串转换成string或者Sales_data对象：
item.combine(string("9-999-99999-9"));
item.combine(Sales_data("9-999-99999-9"));
```
## explicit
抑制构造函数定义的隐式转换，加`explicit`关键字

关键字`explicit`只对一个实参的构造函数有效。因为需要多个实参的构造函数本来就不执行隐式转换。`explicit`只允许出现在类内构造函数时声明处，类外定义时不应重复。

```
class Sales_data {
public:    
    explicit Sales_data(const string& s) : bookNo(s){}//不能再执行从 string 到 Sales_data 的隐式转换。
private    
    string bookNo;   
}
iter.combine(null_book);   //错误，不能执行从 string 到 Sales_data 的隐式初始化
```

### explicit 构造函数只能用于直接初始化
`explicit`构造函数**只能用于直接初始化**，不能用于使用`=`的*拷贝初始化*。理解：因为`=`实际上是采用了拷贝赋值运算符，在传参时会进行隐式转换。

```
Sales_data item1(null_book);  //正确
Sales_data item2 = null_book; //错误
```
# 聚合类
使用户可以直接访问其成员，并具有特殊的初始化语法形式
* 所有成员都是`public`的
* 没有定义任何构造函数
* 没有类内初始值
* 没有基类，也没有`virtual`函数

```
//聚合类：
struct Data{
    int ival;
    string s;
}

//初始化聚合类的数据成员：
//初始值的顺序必须与声明顺序一致，跟数组一样
Data value = { 0, "Anna"};
```

## 字面值常量类
数据成员都是字面值类型的聚合类
或满足以下：
* 数据成员都必须是字面值类型
* 类必须至少含有一个`constexpr`构造函数
* 如果一个数据成员含有类内初始值，则内置类型的成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的`constexpr`构造函数。
* 类必须使用析构函数的默认定义

## `constexpr`构造函数
类的构造函数不能是`const`的，但字面值常量类的构造函数可以是`constexpr`函数。

`constexpr`构造函数可以声明成`=default`或`=delete`。

**`constexpr`构造函数的函数体应该是空的**（原因：`constexpr`函数的函数体只能包含一条返回语句，而构造函数不能包含返回语句）

`constexpr`构造函数**必须初始化所有数据成员**。初始值必须是常量表达式或使用 `constexpr`构造函数。

```
class Debug{
public:
    constexpr Debug(bool b=true):a(b){};
private:
    bool a;
};//定义一个类记得加分号
constexpr Debug prod(false);//定义一个 Debug 类型的对象。实参应为常量表达式。
```

# 类的静态成员
类的静态成员**与类本身直接关联**，而不是与类的对象保持关联。

静态成员可以是`public`或`private`的。

静态成员函数不能声明为`const`的，不能在`static`函数体内使用`this`指针。

可直接使用作用域访问运算符访问静态成员。也可使用类的对象、引用或者指针来访问静态成员。


## 定义静态成员
可以在类内或类外定义静态成员。当在类外定义时，不能重复`static`关键字，**`static`只出现在类内的声明中**。

**不能在类内部初始化静态成员**。只有`constexpr`类型的静态数据成员可以在类内初始化，但是也需要在类外定义(如果已经在类内初始化了，在类外定义时不能再指定一个初始值)。其他的静态数据成员都在类内声明，类外定义并初始化。

## 静态成员可以用的特殊场景
静态数据成员可以是不完全类型，比如静态数据成员的类型可以是它所属的类类型本身。

静态成员可以作为默认实参。