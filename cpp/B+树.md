---
marp: true
theme: gaia
footer: '2023/8/14'
paginate: true
size: 16:9
math: katex
---

# B树的引入
所有结点的平衡因子均等于0的多路查找树

由文件查询系统引入：
- 用数组
用数组存储，查询时间复杂度为`O(n)`太慢了

- 用哈希表
用哈希表(链地址法)存储**需要解决冲突**，且**数据分布不均匀**，最差的情况又退回成数组形式

- 用二叉树
用二叉树存储，如果插入顺序是有序的，会形成**单链**，从而使查询又退回数组形式

- 用平衡二叉树
以牺牲建树的时间为代价，来提高查询时间。但对于插入操作过多的情况，将**消耗大量时间调整树的平衡**。

- 用红黑树
最长子树不超过最短子树的**2倍**即可。
减少了调整树的次数，但**数据量特别大**时，树太**高**

- B树
一个节点存储多个数据。节点中保存数据量n，数据键值key-value,孩子指针p_n。假设一个磁盘块16k，一个数据的value占1k，忽略其他成员，则一个节点只能放16个数据，3层B树只能存4096个数据。**无法存储大量数据**，如果**增加层高**，又回到了**树太高**的问题。

- B+树
B非叶子节点中不存储value。则非叶子节点可以存储大量key。层高也不用增加。

# B树的特点
1. 完美平衡（每个叶节点都在同一层）
2. 除根节点外，其他节点都包含`n`个key，其中`⌈m/2⌉-1⩽n⩽m-1`
3. 每个有`n`个key的内部节点,都会有`n+1`个非空孩子

## "富有"
删除一个key，节点剩余的key数量依然大于等于`⌈m/2⌉-1`

## B树的删除
1. 富有
直接删
2. 不富有
    1. 借兄弟
    2. 借父亲

## B+树的插入
1. 空树，直接插
2. 叶子节点，插入后，`key`的个数不大于`m-1`，插入结束；反之，将该节点分裂成两个节点，前一个节点包含前`m/2`个记录，另一个节点包含剩下记录。将第`m/2+1`个记录进位到父节点中。
3. 接着判断父节点直至`key`的个数不大于`m-1`

## B+树的删除
1. 没有相应key，删除失败
2. 删除叶子节点中对应的key，如果剩余节点数大于等于`⌈m/2⌉-1`，删除结束。
3. 若兄弟节点（同一个父节点）“富有”，向兄弟节点借一个`key`，并更新父节点中的`key`
4. 若兄弟节点“不富有”，当前节点和兄弟节点合并，删除父节点中的`key`
5. 如果父节点节点剩余节点数大于等于`⌈m/2⌉-1`，删除结束。
6. 若兄弟节点（同一个父节点）“富有”，向兄弟节点借一个`key`，并更新父节点中的`key`
7. 若兄弟节点“不富有”，当前节点和兄弟节点合并，并从父节点中拿一个`key`。
注：
    **删除关键字在路径上时，需要更新。**