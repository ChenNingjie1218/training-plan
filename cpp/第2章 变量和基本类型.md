---
marp: true
theme: gaia
footer: '2023/6/14'
paginate: true
size: 16:9
math: katex
---

---
## 字符型
类型`char`和类型`signed char`不一样，类型`char`是否带符号，由编译器决定

## 执行浮点数运算选用double
有些机器双精度运算比单精度还快

## 类型转换
浮点型转整形是**去尾**

给无符号类型赋一个超过它表示范围的值时，结果是**取模后的余数**，即尾巴部分。

给带符号类型赋一个超过它表示范围的值时，结果是**未定义**的

## 含有无符号的表达式
会转换成无符号的数，所以**不要混用带符号类型和无符号类型**

给无符号数赋一个负值，结果等于这个负数加上无符号数的模

## 分多行书写的字符串字面值
```
std::cout << "a really, really long string literal "
             "that spans two lines" << std::endl;
```

## 变量与对象
### 变量
就是一块具名的、可供程序操作的**存储空间**

### 对象
一块能存储数据并具有某种类型的**内存空间**

## 初始化
**初始化和赋值是两个完全不同的操作**
赋值是把对象的当前值**擦除**，以一个新值替代

## 默认初始化
定义于任何函数体之外的变量被初始化为0；
定义于函数体内部的内置类型变量将不被初始化，值是**未定义**的

## 变量声明与定义
### 声明
告知程序名字
`extern`

包含初始化即变为定义，在函数体内部不可初始化
### 定义
创建与名字关联的实体（申请存储空间）

**变量能且只能被定义一次，但可以被多次声明**

## 标识符
1. 不能连续出现两个下划线
2. 不能以下划线紧连大写字母开头
3. 定义在函数体外的标识符不能以下划线开头

## 全局作用域本身没有名字
当作用域操作符的左侧为空时，请求的是全局变量

## 复合类型
### 引用
起别名
**引用必须初始化**
**引用本身不是一个对象，所以不能定义引用的引用**
**引用只能绑定在对象上，不能与字面值或表达式计算结果绑定在一起**

### 指针
#### 与引用的区别
1. 本身是一个对象，允许赋值和拷贝，可以在生命周期内指向几个不同的对象
2. 无须在定义时赋初值

**引用不是对象，没有实际地址，所以不能定义指向引用的指针**
**指针必须匹配类型**

#### 指针的值
1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针
4. 无效指针

#### 空指针
最好使用nullptr，建议初始化所有指针

**把int变量赋值给指针是错误的操作，即使值恰好等于0**

### const限定符
const对象**必须初始化**
const对象一旦创建后其值就不能再改变

### const的引用
不允许非常量引用指向一个常量对象：
```
const int ci = 1024;
int &r2 = ci;//错误
```

允许为一个**常量引用**绑定**非常量的对象**、**字面值**甚至**一般表达式**
```
const int &r1 = 42;//正确
```
### 常量指针和指向常量的指针
注意区别谁是**常量**
指针是常量，即指向的地址不能变，但指向地址中的内容可以变
指向的对象是常量，即指针可以变，但指向的对象中的内容不能变

### 底层const的限制
```
const int i = 0;
const int *p1 = &i;//p1具有底层const
int *p = p1;//错误，p1具有底层const，而p没有，如果正确，就可以用p去改变p1指向的内容
```
归根到底就是不能使改变常量的操作合理化。

### 常量表达式
**值不会改变**并且**在编译过程就能得到计算结果**的表达式

#### constexpr
为了分辨是否是常量表达式。推荐使用constexpr来定义常量表达式。

一个constexpr指针的初始值必须是`nullptr`或者`0`,或者存储于某个**固定地址**中的对象。
用constexpr定义一个指针，只对指针生效：
```
constexpr int *np =nullptr;//常量指针
const int i = 42;
constexpr const int *p = &i;//指向常量的常量指针 
```

## 类型别名
### typedef和using
```
typedef double wages;
using wages = double;
```

```
typedef char *pstring;
const pstring cstr = 0; //这是一个指向char的常量指针
```
而不是`const char *cstr = 0`,即指向常量字符的指针。不同于直接将`pstring`换成`char *`

## auto
编译器分析表达式所属类型，**必须有初始值**
在一条语句中声明多个变量时，所有变量的初始基本类型**必须一样**
忽略顶层`const`（若要保留，明确指出：`const auto`），底层`const`被保留

## decltype
