---
marp: true
theme: gaia
footer: ''
paginate: true
size: 16:9
math: katex
---

# 关联容器
按关键字来保存和访问
- `map`：映射，关联数组
- `set`：集合

允许重复关键字：`multi`
无序容器：`unordered`*使用哈希函数来组织元素*

`map`和`multimap`都在头文件`map`中，`set`和`multiset`都在头文件`set`中。无序容器在`unordered_map`和`unordered_set`中。

---

关联容器的迭代器都是**双向**的
一个`map`或`set`中的**关键字必须是唯一的**

## 有序容器
对于有序容器，关键字类型**必须定义元素比较**的方法
```
multiset<Sales_data, decltype(compareIsbn)*>
    bookstore(compareIsbn);

//注意：比较操作类型是函数指针类型
//用compareIsbn来初始化bookstore对象，表示添加元素时，通过调用compareIsbn来排序
```

## `pair`
定义在头文件`utility`中
**`map`的元素是`pair`**
### 返回`pair`对象的函数
```
return {v.back(), v.back().size()};//列表初始化

return pair<string, int>();//隐式构造返回值

return make_pair(v.back(), v.back().size());//利用make_pair
```

## 关联容器操作
```
key_type //关键字类型
mapped_type //map中关键字关联的类型
value_type //对于set，与key_type相同；
            //对于map，为pair<const key_type, mapped_type>
```
`map`的元素`pair`的**关键字部分**是`const`的，但`key_type`不是
```
map<string, int>::key_type v1;//v1是string
map<string, int>::value_type v2;//v2是pair<const string, int>
```

## 关联容器迭代器
一个`map`的`value_type`是一个`pair`，可以改变`pair`的值，但不能改变关键字成员的值
```
auto map_it = word_count.begin();
map_it->first = "new key";//错误
```

---

`set`的迭代器都是**只读**的：
```
*set_it = 42;//错误
```
**迭代器按关键字升序排列**

## 关联容器和算法
*通常不对关联容器使用泛型算法*。因为关键字是`const`的，所以不能将关联容器传递给修改或重排容器元素的算法。实际编程中，关联容器使用算法，一般是当做源序列，要么当做目的位置。

## 添加元素
```
//函数返回一个pair,包含一个迭代器指向具有指定关键字的元素，以及一个指示插入是否成功的bool值
c.insert(v)
c.emplace(args)

//函数返回void
c.insert(b, e)
c.insert(il)

//迭代器p指示从哪里开始搜索新元素应该存储的位置。返回一个迭代器，指向具有给定关键字的元素
c.insert(p, v)
c.emplace(p, args)
```
对于允许重复关键字的容器，接受单个元素的`insert`操作返回一个指向新元素的迭代器，**无须返回bool值**

## 删除元素
```
c.erase(k)//删除每个关键字为k的元素，返回删除数量，size_type类型
c.erase(p)//返回指向p之后元素的迭代器
c.erase(b,e)//返回e
```

## `map`的下标操作
使用下标运算符时，如果关键字并不在`map`中，会为它创建一个元素并插入到`map`中，关联值将被**值初始化**。
```
word_count["Anna"] = 1;

//1.搜索关键字“Anna”，没找到
//2.创建一个pair插入。关键字是const string保存Anna，
//值进行值初始化，例子中这里为0！
//3.提取出新插入的元素，将1赋值给它

c[k]
c.at(k)//带参数检查
```
一般情况下，解引用一个迭代器所返回的类型与下标运算符返回的类型一样。对`map`而言，使用下标操作，返回`mapped_type`对象，解引用返回`value_type`对象

**如果只想查找，而不想添加新元素，应该使用`find`**
## 访问元素
```
lower_bound和upper_bound不适用于无序容器
下标和at操作只适用于非const的map和unordered_map

c.find(k)//返回迭代器
c.count(k)//统计关键字等于k的元素数量
c.lower_bound(k)//返回一个迭代器，指向第一个关键字不小于k的元素
c.upper_bound(k)//返回一个迭代器，指向第一个关键字大于k的元素
c.equal_range(k)//返回一个pair，表示关键字等于k的元素的范围
```

## 无序容器
不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的`==`运算符

通常可以用一个无序容器替换对应的有序容器，**但是输出不同**

### 管理桶
无序容器在存储上组织为一组桶。无序容器使用一个哈希函数将元素映射到桶。
```
桶接口
c.bucket_count()//正在使用的桶数量
c.max_bucket_count()//能容纳的最多的桶数量
c.bucket_size(n)//第n个桶中有多少元素
c.bucket(k)//关键字为k的元素在哪个桶中
桶迭代
local_iterator//可以用来访问桶中元素的迭代器
const_local_iterator
c.begin(), c.end()
c.cbegin(), c.cend()
哈希策略
c.load_facotr()//每个桶的平均元素数量，返回float值
c.max_load_factor()//试图维护的平均桶大小，返回float值。
                   //c会在需要时添加新的桶，以使得load_factor <= max_load_factor
c.rehash()//重组存储，使得bucket_count >= n
          //且bucket_count > size / max_load_factor
c.reserve(n)//重组存储，使得c可以保存n个元素且不必rehash
```
### 无序容器对关键字类型的要求
- 使用`==`运算符来比较元素，还使用一个`hash<key_type>`类型的对象来生成每个元素的哈希值。

- 我们可以直接定义关键字是内置类型(包括指针类型)、`string`还有智能指针类型的无序容器。
- 我们不能直接定义关键字类型为自定义类类型的无序容器。需要重载比较操作。
```
size_t hasher(const Sales_data &sd){
    return hash<string>() (sd.isbn());//一个hash<string>匿名对象，调用仿函数，传入sd.isbn()
}

bool eqOp(const Sales_data &lhs, const Sales_data &rhs){
    return lhs.isbn() == rhs.isbn()
}

using SD_multiset = unordered_multiset<Sales_data,
                    decltype(hasher)*, decltype(eqOp)*>;//注意都是函数指针
//参数是桶大小，哈希函数指针和相等性判断运算符指针
SD_multiset bookstore(42, hasher, eqOp);
```
*如果类定义了`==`运算符，则可以只重载哈希函数*