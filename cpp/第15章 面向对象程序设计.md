---
marp: true
theme: gaia
footer: ''
paginate: true
size: 16:9
math: katex
---

# 面向对象程序设计
- 数据抽象
    将类的接口与实现分离
- 继承
    定义相似的类型并对其相似关系建模
- 动态绑定
    在一定程度上忽略相似类型的区别，而以统一的方式使用他们的对象

## 继承
- 虚函数

    函数前加`virtual`
    基类希望它的派生类各自定义**适合自身**的版本
    派生类**显式注明**改写基类的虚函数：在函数形参列表之后增加一个`override`关键字，可以让编译器帮我们检查是否覆盖了已存在的虚函数。

- 类派生列表
    明确指出继承于哪个基类
    首先是一个**冒号**，后面紧跟以**逗号**分隔的**基类列表**，其中每个基类前面可以有**访问说明符**
```
class Bulk_quotte : public Quote{
    
}
```
## 动态绑定
也称为运行时绑定
**使用基类的引用(或指针)调用一个虚函数**

## 定义基类
- 基类通常都应该定义一个**虚析构函数**，即使该函数不执行任何实际操作。
- 关键字`virtual`只能出现在**类内部**的声明语句之前而不能用于类外部的函数定义。
- 基类希望它的派生类有权访问该成员，同时禁止其他用户访问：用`protect`访问运算符

## 定义派生类
- 单继承
    只继承自一个类
- 多重继承
    继承自多个类

### 派生类到基类的类型转换
派生类对象中**含有**与其基类对应的组成部分，可以**把派生类的对象当成基类对象**来使用，也可以将**基类的指针或引用**绑定到派生类对象中的基类部分上。这种转换称为**派生类到基类的类型转换**。

### 派生类的构造函数
派生类的构造函数首先在初始化列表中**调用基类的构造函数**初始化基类部分，然后**按照声明的顺序**依次初始化派生类的成员。

### 继承与静态成员
如果基类定义了一个**静态成员**，则在整个继承体系中**只存在该成员的唯一定义**。

### 派生类的声明
不包含它的派生列表
```
class Bulk_quote : public Quote; //错误
class Bulk_quote;//正确
```

### 被用作基类的类
- **必须已经定义而非仅仅声明**。
- 一个类**不能**派生它本身
- 一个类是基类，同时也可以是一个派生类
    - 直接基类
        出现在派生列表中
    - 间接基类
        派生类由直接基类继承而来
### 防止继承发生
类名后面跟一个`final`关键字
```
class NoDerived final{}
```

## 类型转换与继承
### 静态类型与动态类型
- 静态类型
在编译时总是已知的，它是变量声明时的类型或表达式生成的类型
- 动态类型
变量或表达式表示的内存中的对象的类型。**直到运行时才可知**。

如果表达式**既不是引用也不是指针**，则它的动态类型永远于静态类型一致。

### 不存在从基类向派生类的隐式类型转换
```
//即使一个基类指针或引用绑定在一个派生类对象上，也不能执行从基类向派生类的转换
Bulk_quote bulk;
Quote *itemP = &bulk;//正确
Bulk_quote *bulkP = item;//错误
```
因为编译器只能通过检查指针或引用的**静态类型**来推断转换是否合法。

如果在基类中含有一个或多个虚函数，可以使用`dynamic_cast`请求一个类型转换，该转换的安全检查将在运行时执行。
如果已知某个基类向派生类的转换是安全的，则可以使用`static_cast`来强制覆盖掉编译器的检查工作。

### 在对象之间不存在类型转换
当用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象的**基类部分**会被拷贝、移动或赋值，派生类部分将被忽略。**因为是调用的基类的函数**。

## 虚函数
### 派生类中的虚函数
- 形参类型必须与被它覆盖的基类函数完全一致。
- 返回类型也必须匹配，除非返回的是类本身的指针或引用。

### 虚函数与默认实参
虚函数也可以拥有默认实参。
如果某次函数调用使用了默认实参，则该实参值由本次调用的**静态类型**决定。即用基类的引用或指针调用函数，传入的**都是基类函数定义的**默认实参！

### 回避虚函数机制
使用**作用域**运算符
当一个派生类的虚函数调用它覆盖的基类的虚函数版本时。

## 抽象基类
含有纯虚函数的类
### 纯虚函数
`=0`
无须定义
只能出现在**类内部**的虚函数声明语句处
```
double net_price(std::size_t) const = 0;
```

为纯虚函数提供定义，函数体必须定义在类的**外部**。

不能(直接)创建一个抽象基类的对象。

## 重构
负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。

**使用了**这些类的代码**无须进行任何改动**。一旦类被重构，意味着**必须重新编译**含有这些类的代码。

## 访问控制与继承
- 派生类的成员或友元**只能通过派生类对象**来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。
```
class Base{
protected:
    int prot_mem;
}

class Sneaky: public Base{
    friend void clobber(Sneaky&);//能访问Sneaky::prot_mem
    friend void clobber(Base&);//不能访问Base::prot_mem
}

//正确：clobber能访问Sneaky对象的private和protected成员
void clobber(Sneaky &s){
    s.j = s.prot_mem = 0;
}

//错误：clobber不能访问Base的protected成员
void clobber(Base &b){
    b.prot_mem = 0;
}
```

### 公有、私有和受保护继承
派生访问说明符对于派生类的成员(及友元)能否访问其直接基类的成员没什么影响。它的目的是**控制派生类用户**(包括派生类的派生类在内)对于基类成员的访问权限。

用来控制继承自派生类的新类的访问权限。

### 类的设计与受保护的成员
- 普通用户
编写代码**使用类的对象**，这部分代码只能访问类的公有(接口)成员
- 类的实现者
负责**编写类的成员和友元的代码**，既能访问类的公有部分，也能访问类的私有(实现)部分。
- 派生类
基类把希望派生类能够使用的部分声明成受保护的。

### 友元与继承
友元关系**不能传递**，友元关系也**不能继承**

`Pal`是`Base`的友元，`Pal`能够访问`Base`对象的成员，**包括`Base`对象内嵌在其派生类对象中的情况**。

### 改变个别成员的可访问性
通过使用`using`声明
派生类只能为那些它可以访问的名字提供`using`声明

### 默认的继承保护级别
使用`class`关键字定义的派生类是私有继承；
使用`struct`关键字定义的派生类是公有继承。

### 继承中的类作用域
当存在继承关系时，派生类的作用域**嵌套**在其基类的作用域之内。即派生类的成员会隐藏同名的基类成员。

可以通过**作用域**运算符来使用一个被隐藏的基类成员。

声明在内层作用域的函数并**不会重载**声明在外层作用域的函数。因此，定义派生类中的函数**也不会重载**其基类中的成员。即派生类成员和基类成员的形参列表不一样，基类成员也**仍然会被隐藏掉**。

#### 覆盖重载的函数
为重载的成员提供一条`using`声明语句，这样就无须覆盖基类中的每一个重载版本了。`using`声明语句**指定一个名字而不指定形参列表**。只需要定义其特有的函数就行了。

## 构造函数与拷贝控制
一个类需要析构函数，那么它也同样需要拷贝和赋值操作。基类的析构函数并**不遵循该准则**。虚析构函数内容为空，不知道是否需要拷贝和赋值操作。

**虚析构函数将阻止合成移动操作**。

如果在基类中没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作。

### 派生类的拷贝控制成员
析构函数只负责销毁派生类**自己分配的资源**。对象的销毁顺序正好与其创建的顺序**相反**，派生类析构函数首先执行，然后是基类的析构函数，依次类推，沿着**继承体系的反方向**直至最后。

默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果想要拷贝(或移动)基类部分，则必须在派生类的构造函数初始值列表中**显式地使用**基类的拷贝(或移动)构造函数。

### 继承的构造函数
类不能继承默认、拷贝和移动构造函数。

派生类继承基类构造函数的方式：提供一条注明了(直接)基类名的`using`声明语句。
```
using Disc_quote::Disc_quote;//继承Disc_quote的构造函数

//编译器生成的构造函数为
derived(parms) : base(args){}
//derived是派生类的名字，base是基类的名字，parms是构造函数的形参列表，args是派生类构造函数的形参传递给基类的构造函数。
```
如果派生类有自己的数据成员，它们将会**被默认初始化**。

`explicit`或`constexpr`属性将会被继承。

当一个基类构造函数含有**默认实参**，这些实参将**不会被继承**。

## 容器与继承
采取**间接**存储，即使用基类(智能)指针。

## 继承与组合
- 派生类应该反映与基类的一种"是一种(Is A)"关系
- 成员反映"有一个(Has A)"关系