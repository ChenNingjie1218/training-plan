---
marp: true
theme: gaia
footer: '2023/6/16'
paginate: true
size: 16:9
math: katex
---

# 传值参数
c++ 中建议使用引用形参代替指针形参

# 传引用参数
引用形参在传递实参时直接传入对象。

如果函数不需要改变引用形参的值，最好声明为常量引用。

# 数组形参
数组的两个特殊性质：
1. 不允许拷贝数组
2. 使用数组时常会将其转换成指针

```
void print(const int*);
void print(const int[]);
void print(const int[10]);//三种声明等价，数字 10 没有什么实际影响
```
编译器只检查传入的实参是否为 const int* 类型。

## 使用数组做形参确保数组访问不越界的方法
1. 使用一个结束标记指定数组已结束，典型代表为 C 风格字符串
2. 传递指向数组首元素和尾后元素的指针
3. 专门定义一个表示数组大小的形参。

# 有返回值函数
**引用返回左值**
返回引用的函数返回的是左值，其他返回类型得到右值。
可以为返回类型是非常量引用的函数的结果赋值。
```
get_val(s,0) = 'A';
```

## 使用尾置返回类型
任何函数的定义都可以使用尾置返回，但是它更适用于返回类型复杂的函数
```
auto func() -> int;//返回 int 类型
auto func() -> int(*)[10];//返回一个指向 int 数组的指针
```

## 使用 decltype
如果已知函数返回的指针将指向哪个数组，可以使用 decltype
```
int odd[]={1,3,5,7,9};
decltype(odd)* func();//返回一个数组指针
```
注意 decltype 的结果是一个数组，要返回数组指针要加星号。

# 函数重载
main 函数不能重载

函数重载无法区分顶层 const 形参和非顶层 const 形参，但是可以区分底层 const 形参与普通形参
```
int func(int i);
int func(const int i);//顶层const，无法区分，相当于重复声明

int func(int* p);
int func(int* const p);//顶层const，无法区分，相当于重复声明

int func(int* p);
int func(const int* p);//底层const，可以区分，一个普通指针，一个常量指针

int func(int& i);
int func(const int& i);//底层const，可以区分，一个普通引用，一个常量引用
```

最好只重载确实非常相似的操作

## const_cast 在重载中的应用
强制类型转换 const_cast 在重载函数中最有用。一个函数可能同时要有接受常量引用的版本也要有接受非常量引用的版本。

当要重载常量引用与非常量引用的版本时，在非常量引用的版本中可以通过 const_cast 将参数和返回值从常量引用转换为非常量引用，以实现对常量引用版本的调用。

```
string& s;
const_cast <const string&> (s);// 将 s 转换为常量引用
const_cast <string&> (s);// 将 s 转换回非常量引用
```

# 将规模较小的操作定义为函数的优点
1. 阅读和理解函数调用更简单
2. 使用函数可以确保行为统一
3. 修改函数更方便
4. 函数可以被重复利用

## 使用内联函数可以避免调用函数的时间开销
在函数前用 inline 声明一下即表明是内联函数
内联函数适用于规模小、流程直接、频繁调用的函数

## constexpr函数
constexpr 函数被隐式地指定为内联函数

cosntexpr 是指能用于常量表达式的函数。但是 constexpr 函数不一定返回常量表达式。

constexpr 函数的返回类型及所有的形参类型都必须是字面值类型，函数体中必须有且只有一条 return 语句。

内联函数和 constexpr 函数可以多次定义，但是多个定义必须完全一致。

应该把内联函数和constexpr函数的定义放到头文件里。

# 函数指针的别名
函数指针写起来很复杂，尤其是将函数指针作为函数的返回值时，因此一般为其定义别名。定义别名时要注意区分函数类型、函数指针。

下面几个等价：定义的别名都是函数类型。
```
typedef bool func(const string&, const string&);    // 定义了一个别名：func，但是 func 是函数类型
typedef decltype(Compare) func2;                    // 定义了一个别名：func2，func2 也是函数类型
using func3 = bool(const string&, const string&);   // 定义了一个别名：func3，func3 也是函数类型
```
注意 decltype(函数名) 返回的不是指针，是函数类型，加上 * 才表示函数指针。
下面几个等价：定义的别名都是函数指针。
```
typedef bool (*func)(const string&, const string&);  // 定义了一个别名：func， func 是函数指针
typedef decltype(Compare)* func2;                    // 定义了一个别名：func2，func2 也是函数指针
using func3 = bool(*)(const string&, const string&); // 定义了一个别名：func3，func3 也是函数指针
```


