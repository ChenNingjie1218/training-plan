---
marp: true
theme: gaia
footer: ''
paginate: true
size: 16:9
math: katex
---
# 调用函数
## 函数的调用
1. 实参初始化函数对应的形参
2. 将控制权转移给被调用函数
## `return`语句
1. 返回`return`语句中的值
2. 将控制权从被调用函数转移回主调函数

# 实参和形参
**没有规定实参的求值顺序**

# 自动对象
只存在于块执行期间的对象

# 指针形参
c++ 中建议使用引用形参代替指针形参

# 传引用参数
引用形参在传递实参时直接传入对象。

如果函数不需要改变引用形参的值，最好声明为常量引用。

# 数组形参
数组的两个特殊性质：
1. 不允许拷贝数组
2. 使用数组时常会将其转换成指针

```
void print(const int*);
void print(const int[]);
void print(const int[10]);//三种声明等价，数字 10 没有什么实际影响
```
编译器只检查传入的实参是否为 const int* 类型。

## 使用数组做形参确保数组访问不越界的方法
1. 使用一个结束标记指定数组已结束，典型代表为 C 风格字符串
2. 传递指向数组首元素和尾后元素的指针
3. 专门定义一个表示数组大小的形参。

## 数组引用形参
```
void print(int (&arr)[10]){ //只能将函数作用于大小为10的数组
    ...
}
```
数组的大小是构成数组类型的一部分。

# `main`处理命令行选项
```
int main(int argc, char *argv[]){//argc:数组中字符串的数量
    ...
}
或
int main(int argc, char **argv){
    ...
}
```
实参从`argv[1]`开始，`argv[0]`保存程序的名字，而非用户输入

# 含有可变形参的函数
## initializer_list
**所有的实参类型相同**
定义在同名头文件中
```
void error_msg(initializer_list<string> il){
    ...
}
```
提供的操作：
```
initializer_list<T> lst;
initializer_list<T> lst{a,b,c,...};
lst2(lst);
lst2 = lst;
lst.size();
lst.begin();
lst.end();
```
## 可变参数模板
（待补充）

## 省略符号
```
void foo(parm_list, ...);
void foo(...);
```
**只能出现在形参列表的最后一个位置**

# 有返回值函数
**引用返回左值**
返回引用的函数返回的是左值，其他返回类型得到右值。
可以为返回类型是非常量引用的函数的结果赋值。
```
get_val(s,0) = 'A';//get_val返回一个引用类型
```
## 返回数组指针
### 使用类型别名
```
typedef int arrT[10];
或
using arrT = int[10];

arrT* func(int i); //返回一个指向含有10个整数的数组的指针
```

### 声明一个返回数组指针的函数
```
Type (*function(parameter_list))[dimension];

int (*func(int i))[10];
```

### 使用尾置返回类型
任何函数的定义都可以使用尾置返回，但是它更适用于返回类型复杂的函数
```
auto func() -> int;//返回 int 类型
auto func() -> int(*)[10];//返回一个指向 int 数组的指针
```

### 使用 decltype
如果已知函数返回的指针将指向哪个数组，可以使用`decltype`
```
int odd[]={1,3,5,7,9};
decltype(odd) *func();//返回一个数组指针
```
注意`decltype`的结果是一个数组，要返回数组指针要加`*`。

# 函数重载
**`main`函数不能重载**
应该在形参数量上或形参类型上有所不同

一个拥有顶层`const`的形参无法和另一个没有顶层`const`的形参区分开来；
但是如果形参是**引用或指针**，则可以通过区分是否有底层`const`来区分
```
int func(int i);
int func(const int i);//顶层const，无法区分，相当于重复声明

int func(int* p);
int func(int* const p);//顶层const，无法区分，相当于重复声明

int func(int* p);
int func(const int* p);//底层const，可以区分，一个普通指针，一个常量指针

int func(int& i);
int func(const int& i);//底层const，可以区分，一个普通引用，一个常量引用
```

最好只重载确实非常相似的操作

## const_cast 在重载中的应用
强制类型转换`const_cast`在重载函数中最有用。一个函数可能同时要有接受*常量引用*的版本也要有接受*非常量引用*的版本。

当要重载*常量引用*与*非常量引用*的版本时，在*非常量引用*的版本中可以通过 `const_cast`将参数和返回值从*常量引用*转换为*非常量引用*，以实现对常量引用版本的调用。

```
const string &shorterString(const string &s1, const string &s2){
    return s1.size() <= s2.size() ? s1 : s2;
}

------------------      重载非常量引用版本        ---------------------
string &shorterString(string &s1, string &s2){
    auto &r = shorterString(const_cast<const string&>(s1),// 转换为常量引用
                            cosnt_cast<const string&>(s2));
    return const_cast<string&>(r); //转换回非常量引用
}
```
# 默认实参
**一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值**
```
int func(int a = 1, int b = 2, int c = 3);

调用：
func(, , 2);//错误，只能省略尾部的实参
```
**要合理设置形参的顺序**，尽量让不怎么使用默认值的排在前面
在函数声明中指定默认参数

# 将规模较小的操作定义为函数的优点
1. 阅读和理解函数调用更简单
2. 使用函数可以确保行为统一
3. 修改函数更方便
4. 函数可以被重复利用

## 内联函数
避免调用函数的时间开销

在函数前用`inline`声明一下即表明是内联函数

内联函数适用于规模小、流程直接、频繁调用的函数

## `constexpr`函数
`constexpr`函数被隐式地指定为内联函数

`cosntexpr`是指能用于常量表达式的函数。但是`constexpr`函数不一定返回常量表达式。

`constexpr`函数的返回类型及所有的形参类型都**必须是字面值类型**，函数体中必须**有且只有**一条`return`语句。

`constexpr`函数体内也可以包含其他语句，这些语句**在运行时不执行任何操作**（空语句，类型别名，`using`声明）

内联函数和`constexpr`函数可以多次定义，但是多个定义必须完全一致。所以应该把内联函数和`constexpr`函数的定义放到头文件里。

# 调试帮助
## `assert`预处理宏
定义在`cassert`头文件中，直接使用预处理器名字，无须提供`using`声明
```
assert(expr);//表达式为假，assert输出信息并终止程序的执行，
             //表达式为真，assert什么也不做

//assert宏常用来检查“不能发生”的条件
//例如要求所有给定单词的长度都大于某个阈值：
assert(word.size() > threshold);
```
**宏名字在程序内必须唯一**，即不能再定义名为`assert`的变量、函数或其他实体。

## `NDEBUG`预处理变量
```
#define NDEBUG //关闭调试状态，assert将什么也不做

//自己编写条件调试代码：
#ifndef NDEBUG
    cerr << _ _func_ _ << endl //_ _func_ _是编译器定义的一个局部静态变量
                               //用于存放函数的名字
#endif
```
|名字|作用|
|:-|:-|
| _ \_func_ _ |存放函数名字的字符串字面值|
|_ \_FILE_ _|存放文件名的字符串字面值|
|_ \_LINE_ _|存放当前行号的整型字面值|
|_ \_TIME_ _|存放文件编译时间的字符串字面值|
|_ \_DATE_ _|存放文件编译日期的字符串字面值|

# 函数指针的别名
函数指针写起来很复杂，尤其是将函数指针作为函数的返回值时，因此一般为其定义别名。定义别名时要注意区分*函数类型*、*函数指针*。

下面几个等价：定义的别名都是函数类型。
```
typedef bool func(const string&, const string&);    // 定义了一个别名：func，但是 func 是函数类型
typedef decltype(Compare) func2;                    // 定义了一个别名：func2，func2 也是函数类型
using func3 = bool(const string&, const string&);   // 定义了一个别名：func3，func3 也是函数类型
```
注意`decltype(函数名)`返回的不是指针，是函数类型，加上`*`才表示函数指针。
下面几个等价：定义的别名都是函数指针。
```
typedef bool (*func)(const string&, const string&);  // 定义了一个别名：func， func 是函数指针
typedef decltype(Compare)* func2;                    // 定义了一个别名：func2，func2 也是函数指针
using func3 = bool(*)(const string&, const string&); // 定义了一个别名：func3，func3 也是函数指针
```


