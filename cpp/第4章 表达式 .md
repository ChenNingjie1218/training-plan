---
marp: true
theme: gaia
paginate: true
size: 16:9
math: katex
---

# 左值和右值
## 右值
当一个对象被用作右值时，用的是对象的值（内容）
## 左值
当一个对象被用作左值时，用的是对象的身份（在内存中的位置）

---
使用关键字 decltype 时，如果表达式的求值结果是左值，decltype 作用于该表达式（不是变量）得到一个引用类型

运算符对于作用对象是左值还是右值会有要求，比如赋值运算符的左侧运算对象必须是左值。

# 求值顺序
```
int i = f1() * f2();
```
**无法知道`f1`和`f2`哪个先调用**

规定了运算顺序的运算符：
1. `&&`
2. `!!`
3. `?:`
4. `,`

# 取余或取模
如果`m%n`不等于`0`，则它的符号**和m相同**

# 短路求值
对于`&&`：左边为假，右边不执行
对于`||`：左边为真，右边不执行

# 声明为引用类型
避免拷贝

# 递增和递减运算符
前置版本将对象本身作为左值返回，后置版本将对象的原始值的**副本**返回
如无必要，不要使用后置版本。
前置版本直接返回改变了的运算对象，后置版本需要将原始值保存下来以便于返回，是一种浪费
后置版本对于整数和指针来说影响不大，对于迭代器而言消耗巨大

## 在一条语句中混用解引用和递增运算符
### *p++ 
`p++`将`p`的值加一，然后返回`p`的初始值的**副本**作为求值结果用于解引用。(**递增运算符优先级高于解引用**)

这是一种提倡的写法，更加简洁，应该习惯于这种写法

# 位运算
强烈建议仅将位运算符用于处理无符号类型
*运算对象是带符号的且为负时，如果处理符号位取决于机器*

## 位移运算符
返回左侧运算对象的**拷贝**作为求值结果
### 左运算符
在右侧插入0
### 右运算符
1. 无符号类型：在左侧插入0
2. 有符号类型：在左侧插入**符号位的副本**或**0**（视具体环境而定）

### 按位求反
`char`类型的运算对象首先被提升成`int`类型，然后逐位求反

# sizeof
sizeof 是一个运算符
返回一条表达式或一个类型名字所占的字节数（`size_t`类型）
```
sizeof(type)
sizeof expr//返回表达式结果类型的大小
```

对数组执行`sizeof`运算符得到的是整个数组所占空间的大小。**不会把数组转换为指针来处理**

对`string`或`vector`对象执行`sizeof`运算只返回该类型固定部分的大小，不会计算对象中的元素占了多少空间

可以用`sizeof`获得数组中元素的个数：
```
sizeof(arr)/sizeof(*arr);//返回的是数组 arr 的元素数量
```
可以用`sizeof`的结果声明数组的维度

# 隐式类型转换的发生场景
1. 比`int`类型小的整型值首先提升为较大的整数类型
2. 在条件里，把非布尔值转换成布尔值
3. 初始化过程中，初始值转换为变量的类型
4. 赋值时，右侧运算对象转换成左侧类型
5. 算数运算或关系运算的运算对象有多种类型，转换成一种。
6. 函数调用

# 数组转化为指针
大多数情况下数组自动转换成指向数组首元素的指针。（decltype关键字参数、取地址符(&)、sizeof、typeid 都不会发生这种转换）

# 指针的转换
`0`或`nullptr`都能转换成任意指针类型。指向非常量的指针能转换成`void*`。指向所有对象的指针都能转换成`const void*`

# 强制转换
```
castname<type>(expression);//type:转换的目标类型，expression：要转换的值
```
`castname`有四种：`static_cast`、`dynamic_cast`、`const_cast`、`reinterpret_cast`。它指定了执行哪种转换。

## static_cast
任何类型转换，只要不包含底层`const`，都可以用`static_cast``
```
double slope = static_cast<double>(j)/i; //将 j 转换成 double 以便执行浮点数除法
```
当**把较大的类型转换为较小的类型**时，`static_cast`很有用。*这时它告诉读者和编译器：我们知道且不在乎精度损失。平时编译器会给警告，显式转换后就不警告了。*

找回存在于`void*`指针中的值：
```
void *p = &d;
double *dp = static_cast<double*>(p);
```

## const_cast
`const_cast`只能改变对象的底层`const`。可以去掉或增加`const`性质。
**只有`const_cast`能改变表达式的常量属性，其他都不行。**
cosnt_cast 常用于有函数重载的上下文中。
```
string &s;
const_cast <const string&> (s);// 将 s 转换为常量引用
const_cast <string&> (s);// 将 s 转换回非常量引用
```

## reinterpret_cast
它依赖于机器，使用门槛很高，且使用时充满风险，不要用它。