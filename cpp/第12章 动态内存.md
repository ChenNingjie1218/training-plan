---
marp: true
theme: gaia
footer: '2023/7/13'
paginate: true
size: 16:9
math: katex
---

# 内存池
## 静态内存
1. 局部`static`对象
2. 类`static`数据成员
3. 定义在任何函数体之外的变量

`static`对象在**第一次使用**前分配，在**程序结束**时销毁
全局对象在**程序启动**时分配，在**程序结束**时销毁

## 栈内存
函数内的非`static`对象。

**定义时**分配，**离开其定义的程序块**时销毁

## 堆
动态分配的对象

**代码显式销毁**

# 动态内存管理
`new`：在动态内存中为对象分配空间并返回一个指向该对象的指针，可对对象进行初始化。
`delete`：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。

释放一块并非`new`分配的内存，或将相同的指针值**释放多次**，其行为是**未定义**的。
## 内存泄露
忘记释放内存

## 使用空悬指针
使用已经释放的内存。

`delete`之后要将指针**置空**。但对其他还指向该内存的指针无用。

# 智能指针
负责**自动释放**所指向的对象。定义在头文件`memory`中。
1. `shared_ptr`:允许多个指针指向同一个对象
2. `unique_ptr`:“独占”所指向的对象
3. `weak_ptr`:伴随类，它是一种弱引用，指向`shared_ptr`所管理的对象。

## `shared_ptr`类
必须提供指针可以指向的类型
```
shared_ptr<T> p;//模板，可以指向类型T的指针
```
### `make_shared`函数
**最安全的分配和使用动态内存的方法**
```
shared_ptr<T> p = make_shared<T>(/*用该参数构造给定类型的对象*/);

//利用auto简化
auto p = make_shared<T>(/*用该参数构造给定类型的对象*/);
```
### 引用计数
计数器递增：
1. 用该`shared_ptr`初始化另一个`shared_ptr`
2. 将该`shared_ptr`作为参数传递给一个函数
3. 作为函数的返回值

计数器递减：
1. 被赋予新值
2. 被销毁

当`shared_ptr`计数器变为0时，就会自动释放自己管理的对象。

如果将`shared_ptr`存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用`erase`删除不再需要的那些元素。

## `unique_ptr`类
**不支持拷贝和赋值**，可以利用`release`或`reset`将指针的所有权转移
```
unique_ptr<string> p2(p1.release()); //p1转移给p2

p2.reset(p3.release());//p2放弃了原来的，重新指向p3
```
可以拷贝或赋值一个即将被销毁的`unique_ptr`：函数返回一个`unique_ptr`或局部对象的拷贝。

### 向`unique_ptr`传递删除器
**尖括号中：**
```
unique_ptr<objT, delT> p(new objT,fcn); //注意delT是一个函数指针类型
```
## `weak_ptr`类
**不控制所指向对象生存期**，指向一个`shared_ptr`管理的对象。

不改变`shared_ptr`的引用计数。由于对象可能不存在，所以不能使用`weak_ptr`直接访问对象，必须调用`lock`(检查所指对象是否存在，存在返回一个指向它的`shared_ptr`，否则返回空`shared_ptr`)

# 内存耗尽
`new`如果不能分配所要求的内存空间，它会抛出一个类型为`bad_alloc`的异常

利用`定位new`阻止它抛出异常，返回空指针：
```
int *p = new (nothrow) int; //如果分配失败，不抛异常，返回空指针
```

# `shared_ptr`和`new`结合使用
智能指针的构造函数是`explicit`的，**必须直接初始化**
```
shared_ptr<int> p1 = new int(1024); //错误
shared_ptr<int> p1(new int(1024)); //正确
```

**不要混合使用普通指针和智能指针**：智能指针把内存释放了，普通指针成为空悬指针

**不要使用`get`初始化另一个智能指针或为智能指针赋值**：用`get`返回的指针初始化或赋值另一个智能指针，两个智能指针是**相互独立**的。

智能指针成员函数`get`是设计来给不能使用智能指针的代码传递一个内置指针。

# `reset`操作
将一个新的指针赋予`shared_ptr`
```
p.reset(new int(1024));//p指向一个新的对象
```

`reset`成员经常与`unique`一起使用，来控制多个`shared_ptr`控制的对象：
```
//改变底层对象之前，要检查是否是唯一用户
if(!p.unique()){
    p.reset(new string*(*p));//我们不是唯一用户，要分配新的拷贝
}
*p += newVal;//现在是唯一用户了，可以改变对象的值
```

# 智能指针和异常
发生异常时，我们直接管理的内存是不会自动释放的。即`new`之后，`delete`之前发生了异常，内存不会被释放。

智能指针可以避免。

# 动态数组
一般使用标准库容器，可以使用默认版本的拷贝、赋值和析构操作。分配动态数组的类**必须定义自己版本的操作**，在拷贝、赋值以及销毁对象时管理所关联的内存。

## `new`和数组
```
int *pia = new int[get_size()];

//或数组类型别名
typedef int arrT[42];
int *p = new arrT;
```
方括号中的大小必须是整型，但**不必是常量**

**当用`new`分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针**，不能对其使用`begin`和`end`，也不能使用范围`for`语句。

**动态分配一个空数组是合法的**，返回一个合法的非空指针（类似尾后指针）

## 释放动态数组
```
//对使用了类型别名分配的动态数组也必须使用[]
delete [] pa;//忽略方括号其行为是未定义的。
            
```
**按逆序销毁**

## 智能指针和动态数组
用`unique_ptr`管理动态数组：
```
unique_ptr<int[]> up(new int[10]);
up.release();//自动用delete[]销毁其指针
```
当用`unique_ptr`指向一个数组时，**不能**使用点和箭头成员运算符。**可以**使用下标运算符来访问数组中的元素。

`shared_ptr`不直接支持管理动态数组，必须提供自己定义的删除器。
```
shared_ptr<int> sp(new int[10], [](int *p){ delete [] p; });
```
访问数组中的元素，必须用`get`获取一个内置指针，然后用它来访问数组元素。

# `allocator`类
定义在`memory`头文件中，将内存分配和对象构造分离开来。（将内存分配和对象构造组合在一起可能会导致不必要的浪费）

```
//同样是一个模板：
allocator<string> alloc;
auto const p = alloc.allocate(n);//分配n个未初始化的string

//在给定位置构造一个元素：
q = p;
alloc.construct(q++);
alloc.construct(q++, 10, 'c');
alloc.construct(q++, "hi");
//额外参数用来初始化构造的对象
```
**还未构造对象的情况下就使用原始内存是错误的**，必须用`construct`构造对象

**必须对每个构造的元素调用`destroy`来销毁它们**

释放内存调用`deallocate`:
```
alloc.deallocate(p, n);
```
传递给`deallocate`的大小参数必须与调用`allocate`分配内存时提供的大小参数具有一样的值。

## 拷贝和填充算法
|uninitialized_copy(b, e, b2)|迭代器b、e范围内元素拷贝到迭代器b2开始的内存中|
|:-|:-|
|uninitialized_copy_n(b, n, b2)|迭代器b开始，n个元素，到迭代器b2开始的内存中|
|uninitialized_fill(b, e, t)|迭代器b、e范围内，用值t创建对象|
|uninitialized_fill(b, n, t)|迭代器b开始，n个元素，用值t创建|

`uninitialized_copy`返回(递增后的)目的位置迭代器
