---
marp: true
theme: gaia
footer: ''
paginate: true
size: 16:9
math: katex
---

# 函数模板
以关键字`template`开始，后跟一个模板参数列表

**在模板定义中，模板参数列表不能为空。**

编译器生成的版本通常被称为**模板的实例**

## 模板类型参数
可以将**类型参数**看作**类型说明符**。可以用来指定**返回类型**或函数的**参数类型**，以及在函数体内用于**变量声明或类型转换**。
```
template <typename T> T foo(T* P){
    T tmp = *p;
    //...
    return tmp;
}
```
类型参数前必须使用关键字`typename`或`class`

## 非类型模板参数
- 表示一个**值**而非一个类型
- 必须是常量表达式
```
template<unsigned N, unsigned M>
```

一个非类型参数可以是一个**整型**，或者是一个指向对象或函数类型的**指针或(左值)引用**。
- 绑定到指针或引用非类型参数的实参必须具有**静态的生存期**。不能用一个**普通(非`static`)局部变量**或**动态对象**作为指针或引用非类型模板参数的实参。指针可以用`nullptr`或`0`来实例化。

## `inline`和`constexpr`的函数模板
说明符放在**模板参数列表之后，返回类型之前**：
```
template <typename T> inline T min(const T&, const T&);
```

## 编写类型无关的代码
编写**比较函数**代码时只使用`<`，可以避免类型不支持`>`的情况。可以用`less`让指针也能正确使用。

**模板程序应该尽量减少对实参类型的要求**

## 模板编译
为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，**模板的头文件通常即包括声明也包括定义**。

# 类模板
类模板的名字**不是**一个类型名

## 类模板的成员函数
定义在类模板之外的成员函数必须以关键字`template`开始，后接类模板参数列表。

默认情况下，一个实例化了的类模板，其成员只有在**使用时**才被实例化。

**处于类模板作用域中**时，编译器处理模板自身引用就好像提供了与模板实参匹配的实参一样:
```
BlobPtr& operator++();

//等同于
BlobPtr<T>& operator++();

```

## 模板类型别名
模板不是一个类型，不能定义一个`typedef`引用一个模板。
应使用如下方法：
```
template<typename T> using twin = pair<T, T>;
twin<string> authors;.//authors是一个pair<string, string>
```

## 类模板的`static`成员
- 类模板的每个实例都有一个**独有**的`static`对象。
- 一个`static`成员函数只有在使用时才会实例化

# 模板参数
## 使用类的类型成员
默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。因此，如果要使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型，通过使用关键字`typename`实现：(不能使用`class`)
```
template <typename T>
typename T::value_type top(const T& c){

}
```

## 模板默认实参与类模板
无论何时使用一个类模板，我们都必须在模板名之后接上尖括号。
```
template <typename T, typename F = less<T>>;//默认模板实参

Numbers<> average_precision;//空<>表示我们希望使用默认类型
```

# 成员模板
**不能是虚函数**。
```
template <typename T> class Blob{
    template <typename It> Blob(It b, It e);
}

//必须同时为类模板和成员模板提供模板参数列表
template <typename T>
template <typename It>
    Blob<T>::Blob(It b, It e){

    }
```
# 控制实例化
在大系统中，在**多个文件**中实例化**相同模板**的额外开销可能非常严重。
通过**显式实例化**来避免这种开销。
```
extern template decalration;//实例化声明
template declaration;//实例化定义
```

## 实例化定义会实例化所有成员
与处理类模板的普通实例化不同，编译器会实例化该类的**所有成员**。

## 效率与灵活性
以智能指针为例。
在**编译**时绑定删除器，`unique_ptr`避免了间接调用删除器的运行时开销；
在**运行**时绑定删除器，`shared_ptr`使用户重载删除器更为方便。

# 模板实参推断
## 类型转换与模板类型参数
能在调用中应用于函数模板的包括：
- `const`转换
- 数组或函数指针的转换
其他类型转换，包括算术转换，派生类向基类的转换以及用户定义的转换，**都**不能应用于函数模板。

## 指定显式模板实参
```
template <typename T1, typename T2, typename T3>
T1 sun(T2, T3);
```
例子中，**没有任何函数实参的类型可用来推断`T1`的类型**。每次调用`sum`时调用者都**必须**为`T1`提供一个**显式模板实参**

显式模板实参按**从左至右**的顺序与对应的模板参数匹配；只有**尾部(最右)参数**的显式模板实参才可以忽略，而且前提是它们**可以从函数参数推断出来**。

对于显式指定了的函数实参，也进行正常的类型转换。

## 尾置返回类型与类型转换
由于尾置返回出现在参数列表之后，**它可以使用函数的参数**
```
template <typename It>
auto fcn(It beg, It end) -> decltype(*beg){
    //...
    return *beg;
}
```
## 进行类型转换的标准库模板
所有迭代器操作都不会生成元素，只能生成元素的引用。为了返回一个元素的**值**而非引用，可以使用标准库的类型转换模板。
头文件`type_traits`中。例如`remove_reference`：
```
template <typename It>
auto fcn2(It beg, It end) ->
    typename remove_reference<decltype(*beg)>::type{//必须用typename告诉编译器这是个类型
        //...
        return *beg;
    }
```

```
remove_reference 
add_const
add_lvalue_reference
add_rvalue_reference
remove_pointer
add_pointer
make_signed
make_unsigned
remove_extend //X[] -> X
remove_all_extents//X[][][] -> X
```

## 函数指针和实参推断
当我们用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型推断模板实参。
```
template <typename T> int compare(const T&, const T&)
int (*pf1)(const int&, const int&) = compare;//T的模板实参为int
```
**必须能唯一确定其类型或值**

## 模板实参推断和引用
### 从左值引用函数参数推断类型
```
template <typename T> void f1(T&); //实参必须是一个左值
template <typename T> void f2(const T&); //可以接受一个右值
```

### 引用折叠和右值引用参数
C++语言允许将一个右值引用绑定到一个左值上，编译器推断模板类型参数为实参的**左值引用类型**。

通常，我们不能(直接)定义一个引用的引用。但是通过**类型别名**或通过**模板类型参数**间接定义是可以的。此时这些引用会形成**折叠**

如果一个函数参数是指向模板参数类型的右值引用，则可以传递给它**任意类型**的实参。如果将一个**左值**传递给这样的参数，则函数参数被实例化为一个普通的**左值引用**。

右值引用通常用于：
- 模板转发其实参
- 模板被重载

可以通过`static_cast`**显式地**将一个左值转换为一个右值引用

## 转发
为了将**实参连同类型不变**地转发给其他函数。
```
template <typename F, typename T1, typename T2>
void flip1(F f, T1 t1, T2 t2){
    f(t2, t1);
}

//注意v2要带着原变量变
void f(int v1, int &v2){
    cout << v1 << " " << ++v2 << endl;
}

flip1(f, j, 42);//不会改变j，t1并非int&
```

通过将一个函数参数定义为一个指向**模板类型参数的右值引用**，我们可以保持其对应实参的所有类型信息。
```
template <typename F, typename T1, typename T2>
void flip2(F f, T1 &&t1, T2 &&t2){
    f(t2, t1);
}

flip2(f, j, 42);//可以改变j。j是一个左值，T1被推断为int&
```
这种方式对于接受左值引用的函数工作的很好，但不能用于接受右值引用参数的函数。从而引入了`forward`标准库设施，它能保持原始实参的类型。
```
void g(int &&i, int& j){
    cout << i << " " << j << endl;
}
flip2(g, i, 42);//错误：不能从一个左值实例化int&&
```

- `forward`
头文件`utility`中。
返回该显式实参类型的右值引用。
```
f(std::forward<T2>(t2), std::forward<T1>(t1));
```

## 重载与模板
对于一个调用匹配了多个函数:
- **只有一个是非模板函数**，则选择此函数
- 没有非模板函数，则选择**更特例化**的模板
- 此调用有歧义

# 可变参数模板
一个接受**可变数目参数**的模板函数或模板类。
- 参数包
可变数目的参数
    - 模板参数包
    表示零个或多个模板参数
    - 函数参数包
    表示零个或多个函数参数

一个类型名后面跟一个**省略号**表示零个或多个给定类型的非类型参数的列表
```
//Args是一个名为Args的模板参数包；rest是一个名为rest的函数参数包
template <typename T, typename... Args> //Args表示零个或多个模板类型参数
void foo(const T &t, const Args& ... rest); //rest表示零个或多个函数类型参数
```
编译器还会**推断包中参数的数目**。

## `sizeof...`运算符
得知包中有多少元素
```
template <typename ... Args> void g(Args ... args){
    sizeof...(Args); //类型参数的数目
    sizeof...(args); //函数参数的数目
}
```
## 包扩展
扩展一个包就是将它**分解**为构成的元素，对**每个**元素**应用模式**，获得扩展后的列表。我们通过在**模式右边**放一个省略号(`...`)来触发扩展操作。
```
//print(os, T1, T2, ..., Tn);
print(os, rest...);

//----------更为复杂的扩展模式-------------
//print(os, debug_rep(a1), debug_rep(a2), ..., debug_rep(an))
print(os, debug_rep(rest)...);

```

# 模板特例化
使用关键字`template`后跟一个空尖括号对(`<>`)
```
template <>
int compare(const char* const &p1, const char* const &p2){
    return strcmp(p1, p2);
}
```

特例化的本质是**实例化一个模板，而非重载它**。因此，**特例化不影响函数匹配**。

*模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是这些模板的特例化版本。*

## 类模板特例化
必须在原模版定义所在的命名空间中特例化它。
首先必须打开命名空间：
```
namespace std{

}//关闭std命名空间；注意：右花括号之后没有分号
```

## 类模板部分特例化
- 不必为所有模板参数提供实参
- 本身还是个模板
- **只能部分特例化类模板，不能部分特例化函数模板**

---
标准库算法都是**函数模板**，标准库容器都是**类模板**