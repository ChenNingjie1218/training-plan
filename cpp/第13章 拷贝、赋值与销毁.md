---
marp: true
theme: gaia
footer: ''
paginate: true
size: 16:9
math: katex
---

## 拷贝控制成员
- 拷贝构造函数
- 拷贝赋值运算符
- 移动构造函数
- 移动赋值运算符
- 析构函数

**拷贝和移动构造函数**定义了当用同类型的另一个对象初始化本对象时做什么
**拷贝和移动赋值运算符**定义了讲一个对象赋予同类型的另一个对象时做什么
**析构函数**定义了当此类型对象销毁时做什么

### 拷贝构造函数
第一个参数时自身类类型，且**任何额外参数都有默认值**。

第一个参数几乎总是一个**`const`的引用**。很多情况下都会**被隐式地使用**，因此拷贝构造函数通常**不应该是`explicit`的**。

#### 拷贝初始化
直接初始化时，编译器使用普通的函数匹配来选择最匹配的构造函数。
拷贝初始化时，编译器将右侧运算对象拷贝到正在创建的对象中，如有需要还要进行**类型转换**。

##### 拷贝初始化发生的情况：
- 用`=`定义变量
- 作为实参传递给**非引用**类型的形参
- 函数返回（**非引用**类型）
- 列表初始化
- 类类型分配对象时。例如初始化标准库容器或调用`insert`或`push`成员(`emplace`是直接初始化)

##### 拷贝构造函数的参数必须是引用类型
如果不是引用类型，那么我们调用拷贝构造函数，就需要拷贝它的实参；为了拷贝实参，又需要调用拷贝构造函数，陷入循环。

### 拷贝赋值运算符
#### 重载运算符
**重载运算符本质上是函数**,关键字`operator`后紧接要定义的运算符的符号。

赋值运算符就是一个名为`operator=`的函数

### 析构函数
由`~`+类名构成。**没有返回值，也不接受参数**，因此不能被重载，对于一个给定的类，只会有唯一的析构函数。

析构函数，首先执行函数体，**然后才销毁成员**。成员按初始化顺序**逆序**销毁。

隐式销毁一个内置指针类型的成员**不会`delete`它所指的对象**。

#### 什么时候调用析构函数
对象被销毁时
- 变量离开作用域
- 对象被销毁，其**成员**被销毁
- 容器被销毁，其**元素**被销毁
- `delete`时被销毁
- 临时对象，当创建它的完整表达式结束时被销毁

当只想一个对象的引用或指针离开作用域时，析构函数不会被执行。

**析构函数体自身并不直接销毁成员**

### 三/五法则
如果要定义一个类，一个基本原则就是**首先确认是否需要一个析构函数**

**如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝构造函数和拷贝赋值运算符。**

解释：
需要析构函数 ===> 分配了动态内存
如果没有自定义的拷贝构造函数和拷贝赋值运算符，即调用合成的，指向的动态内存相同。两个变量在析构时，都调用自定义析构函数，**会导致`delete`两次**。

### `=default`
显式地要求编译器生成合成的版本

在类内用`=default`修饰成员声明时，合成的函数将隐式地声明为**内联的**。如果不想它是内联的，就在类外定义使用`=default`。

**只能对具有合成版本的成员函数使用**

### `=delete`
删除的函数：虽然声明了它们，但不能以任何方式使用它们

**必须出现在函数第一次声明时**。（`=default`可以类内声明时不用，类外定义时用）

**析构函数不能是删除的函数**

### 交换
交换两个对象要进行**一次拷贝和两次赋值**。
```
A temp = a;
a = b;
b = temp;
```
为节约内存分配，**交换其指针**，而不分配该类型的新副本。

### 对象移动
如果对象拷贝后就立即被销毁，**移动而非拷贝对象**会大幅提升性能

#### 右值引用
- 为了支持移动操作
- `&&`

左值表示一个**对象的身份**，右值表示的是**对象的值**


**必须绑定到右值**：
```
int i = 42;
int &&rr = i;//错误，不能将一个右值的引用直接绑定到一个左值上
```

##### 左值持久，右值短暂
右值引用只能绑定到临时对象
- 所引用的对象将要被销毁
- 该对象没有其他用户

##### 变量是左值
不能将一个右值引用绑定到一个**右值引用类型**的变量上
```
int &&rr1 = 42;//正确，字面常量是右值
int &&rr2 = rr1;//错误，变量rr1是左值！
```

#### `move`函数
获得绑定到左值上的右值引用，头文件`utility`
```
int &&rr3 = std::move(rr1);
```
调用`more`意味着承诺：除了对其赋值或销毁它外，我们将不再使用它

### 移动构造函数和移动赋值运算符
移动构造函数的第一个参数是该类类型的一个**右值引用**，**任何额外的参数都必须有默认实参**。

```
StrVec::StrVec(StrVec &&s) noexcept
    :elements(s.elements), first_free(s.first_free), cap(s.cap){
        //令s进入这样的状态——对其运行析构函数是安全的
        s.elements = s.first_free = s.cap = nullptr;
    }
```

---

#### `noexcept`
通知**标准库**该函数不抛出任何异常

在函数的参数列表后指定`noexcept`

**必须在类头文件的声明和定义中都指定`noexcept`**

---

#### 不抛出异常的移动构造函数和移动赋值运算符必须标记为`noexcept`
告诉标准库我们自定义的移动操作不抛出异常。

理解：标准库容器能对异常发生时自身的行为提供保障。例如，`vector`保证，`push_back`发生异常时，`vector`自身不会改变。即`vector`重新分配内存把元素弄过去时，会优先采用拷贝构造函数而不采用移动构造函数。
所以当`vector`重新分配空间时，想要移动我们自定义的类型而不是去拷贝他，必须显式告诉`vector`我们不会抛出异常。

#### 移动赋值运算符
```
StrVec &StrVec::operator=(StrVEct &&rhs) noexcept{
    //直接检测自赋值
    if(this != &rhs){
        free();//释放已有元素
        elements = rhs.elements;//从rhs接管资源
        first_free = rhs.first_free;
        cap = rhs.cap;
        rhs.elements = rhs.first_free = rhs.cap = nullptr;//将rhs置于可析构状态
    }
    return *this;
}
```

**移动操作之后，移动源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设**

#### 合成移动操作
编译器不会为某些类合成移动操作。例如定义了自己拷贝构造函数、拷贝赋值运算符活析构函数的类。

**只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非`static`数据成员都可以移动时，编译器才会合成。**

移动操作永远不会隐式定义为删除的函数。但是如果我们显式地要求编译器生成`=default`的移动操作，**且编译器不能移动所有成员**，则编译器会将移动操作定义为删除的函数。

**定义了一个移动构造函数活移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的。**

#### 移动迭代器
移动迭代器的解引用运算符生成一个右值引用
调用`make_move_iterator`将一个普通迭代器转换为一个移动迭代器

#### 右值引用和成员函数
```
void push_back(const X&);//拷贝
void push_back(X&&);//移动
```

**不需要定义`X&`参数版本和`const X&&`版本**。因为拷贝操作不应该改变该对象；从实参“窃取”数据(实参会失去)，实参不能是`const`的。

##### 参数列表后放置引用限定符
```
class Foo{
    Foo &operator=(const Foo&) &;
}

Foo &Foo::operator=(const Foo &rhs) &{
    return *this;
}
```
引用限定符可以是`&`或`&&`，分别指出`this`指向左值或右值。只能用于(非`static`)成员函数，且**必须同时出现在函数的声明和定义中**。

可以同时使用`const`和引用限定符，引用限定符必须跟随在`const`之后：
```
Foo someMem() const &;
```

如果定义两个或两个以上**具有相同名字和相同参数列表**的成员函数，就**必须对所有函数都加上引用限定符，或者所有都不加**：
```
Foo sorted() &&;
Foo sorted() const;//错误，必须加上引用限定符
```