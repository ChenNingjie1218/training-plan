# 传输层：TCP、UDP和SCTP

## TCP三次握手
![Alt text](res/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)
### 为什么？

- 为了保证可靠性
服务器收到第一个SYN(确认到**客户端发送**没问题)
客户端收到服务器返回的SYN和ACK(确认到服务器的**发送和接收**都没问题)
服务器收到客户端返回的ACK(才确认到**客户端接收**没问题)


## TCP四次挥手
![Alt text](res/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)
### 为什么？

- 确保数据的完整性，确保对方不会再发送数据
服务器如果收到FIN就立即关闭会导致部分数据没有收到，数据不完整

### 二三次为什么不合在一起？

- 服务器将ACK滞后到FIN一起发，客户端会以为自己发的FIN丢失了，而重新发，导致资源浪费

### 为什么客户端在TIME-WAIT阶段要等2MSL?

- 可靠地实现TCP全双工连接的终止
防止客户端发的ACK丢失

- 允许老的重复分节在网络中消逝
关闭连接后，重新建立一个新的连接，TCP必须防止上一个连接的重复分组再现。

## SCTP四次握手
![Alt text](res/SCTP%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

### 为什么？
差别主要是cookie，客户端与服务器都要确保cookie是正确的。

## SCTP三次挥手
![Alt text](res/SCTP%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

### 为什么？
- SCTP有验证标记值，以区分旧连接跟新连接。

## TCP端口号与并发服务器
- **服务器不能指定一个包含多个地址的清单**
运行服务器的主机如果是多宿的，服务器可以指定它只接受到达某个特定本地接口的外来连接。**这里要么选一个接口要么选任意接口**。
- TCP无法仅仅通过查看目的端口号来分离外来的分节到不同端点。**必须查看套接字对的所有4个元素**。

## TCP和SCTP输出需要缓冲区，UDP输出不需要缓冲区
前两者是可靠的，可能会重发。而UDP不用。